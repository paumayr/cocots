/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace at.jku.ssw.Coco
-------------------------------------------------------------------------*/
$namespace=at.jku.ssw.Coco

COMPILER Coco

	static get id() : number { return 0; }
	static get str() : number { return 1; }
	
	public trace : TextWriter ;    // other Coco objects referenced in this ATG
	public tab : Tab;
	public dfa : DFA;
	public pgen : ParserGen;

	genScanner : bool;
	tokenString : string;         // used in declarations of literal tokens
	static get noString(): string { return "-none-"; } // used in declarations of literal tokens

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable = '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

TOKENS
	ident     = letter { letter | digit }.
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.  (. this.tab.SetDDT(this.la.val); .)

	optionSym = '$' letter { letter } '='
	            { digit | letter
	            | '-' | '.' | ':'
	            }.                       (. this.tab.SetOption(this.la.val); .)


COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. var sym : Symbol; var g : Graph; var g1 : Graph; var g2 : Graph; var gramName : string; var s : CharSet; var beg : number;var line : number; .)
=
  [ // using statements
    ANY                          (. beg = this.t.pos; line = this.t.line; .)
    { ANY }                      (. this.pgen.usingPos = new Position(beg, this.la.pos, 0, line); .)
  ]

  "COMPILER"                    (. this.genScanner = true; 
                                   this.tab.ignored = new CharSet(); .) 
  ident                         (. gramName = this.t.val;
                                   beg = this.la.pos; line = this.la.line;
                                 .)
  { ANY }                       (. this.tab.semDeclPos = new Position(beg, this.la.pos, 0, line); .)
  [ "IGNORECASE"                (. this.dfa.ignoreCase = true; .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<{ typ : Node.t }> }]
  [ "PRAGMAS" { TokenDecl<{ typ : Node.pr }> }]
  { "COMMENTS"                          (. var nested = false; .)
                                        (. var tokenexprg1 : { g : Graph } = { g : null }; var tokenexprg2 : { g : Graph } = { g : null }; .)
    "FROM" TokenExpr<tokenexprg1>       (. g1 = tokenexprg1.g; .) 
    "TO" TokenExpr<tokenexprg2>         (. g2 = tokenexprg2.g; .)
    [ "NESTED"                          (. nested = true; .)
    ]                                   (. this.dfa.NewComment(g1.l, g2.l, nested); .)
  }
  {                                     (. var sets : { s: CharSet} = { s : null }; .)
     "IGNORE" Set<sets>                 (. s = sets.s; this.tab.ignored.Or(s); .)
  }

  SYNC 
  "PRODUCTIONS"                 (. if (this.genScanner) this.dfa.MakeDeterministic();
                                   this.tab.DeleteNodes();
                                 .)
  { ident                       (. sym = this.tab.FindSym(this.t.val);
                                   var undef = sym == null;
                                   if (undef) sym = this.tab.NewSym(Node.nt, this.t.val, this.t.line);
                                   else {
                                     if (sym.typ == Node.nt) {
                                       if (sym.graph != null) this.SemErr("name declared twice");
                                     } else { 
                                       this.SemErr("this symbol kind not allowed on left side of production");
                                     }
                                     sym.line = this.t.line;
                                   }
                                   var noAttrs : bool = sym.attrPos == null;
                                   sym.attrPos = null;
                                 .)
    [                             (. var retsym : { sym : Symbol } = { sym : sym }; .)
     AttrDecl<retsym> ]           (. sym = retsym.sym;
                                     if (!undef) {
                                       if (noAttrs != (sym.attrPos == null)) {
                                         this.SemErr("attribute mismatch between declaration and use of this symbol");
                                     }
                                   }
                                 .)
    [                            (. var retSemPos : { pos : Position } = { pos : null}; .)
      SemText<retSemPos>		(. sym.semPos = retSemPos.pos; .)
	 ] WEAK
    '='                         (. var expressionret : { g : Graph } = { g : null }; .)
    Expression<expressionret>   (. g = expressionret.g;
	                               sym.graph = g.l;
                                   this.tab.Finish(g);
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (gramName != this.t.val) {
                                     this.SemErr("name does not match grammar name");
                                     this.tab.gramSy = this.tab.FindSym(gramName);
                                   }
                                   if (this.tab.gramSy == null) {
                                     this.SemErr("missing production for grammar name");
                                   } else {
                                     sym = this.tab.gramSy;
                                     if (sym.attrPos != null) {
                                       this.SemErr("grammar symbol must not have attributes");
                                     }
                                   }
                                   this.tab.noSym = this.tab.NewSym(Node.t, "???", 0); // noSym gets highest number
                                   this.tab.SetupAnys();
                                   this.tab.RenumberPragmas();
                                   if (this.tab.ddt[2]) {
                                      this.tab.PrintNodes();
                                   }
                                   if (this.errors.count == 0) {
                                     Console.prototype.log("checking");
                                     this.tab.CompSymbolSets();
                                     if (this.tab.ddt[7]) { this.tab.XRef(); }
                                     if (this.tab.GrammarOk()) {
                                       Console.prototype.log("parser");
                                       this.pgen.WriteParser();
                                       if (this.genScanner) {
                                         Console.prototype.log(" + scanner");
                                         this.dfa.WriteScanner();
                                         if (this.tab.ddt[0]) { this.dfa.PrintStates(); }
                                       }
                                       Console.prototype.log(" generated");
                                       if (this.tab.ddt[8]) { this.pgen.WriteStatistics(); }
                                     }
                                   }
                                   if (this.tab.ddt[6]) { this.tab.PrintSymbolTable(); }
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. var s : CharSet; .)
=
  ident                         (. var name = this.t.val;
                                   var c = this.tab.FindCharClass(name);
                                   if (c != null) { this.SemErr("name declared twice"); }
                                 .)
  '='                         (. var rets : { s: CharSet } = { s : null }; .)
	Set<rets>                    (. if (rets.s.Elements() == 0) { this.SemErr("character set must not be empty"); }
                                   this.tab.NewCharClass(name, rets.s);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<s : CharSet;>              (. var rets2 : { s: CharSet} = { s : null }; .)
=
  SimSet<ret>
  { '+' SimSet<rets2>          (. ret.s.Or(rets2.s); .)
  | '-' SimSet<rets2>          (. ret.s.Subtract(rets2.s); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<s : CharSet;>            (. var n1 : number; var n2 : number; .)
=                               (. ret.s = new CharSet(); .)
( ident                         (. var c = this.tab.FindCharClass(this.t.val);
                                   if (c == null) { this.SemErr("undefined name"); } else { ret.s.Or(c.set); }
                                 .)
| string                        (. var name = this.t.val;
                                   name = this.tab.Unescape(name.substring(1, name.length-2));
                                   for (var i = 0; i < name.length; i++)
                                   {
	                                 var ch = name.charAt(i);
                                     if (this.dfa.ignoreCase) { ret.s.Set(ch.toLowerCase().charCodeAt(0)); }
                                     else { ret.s.Set(ch.charCodeAt(0)); }
                                   }  .)
|                               (. var n1ret : { n : number } = { n : null }; .)
  Char<n1ret>                   (. ret.s.Set(n1ret.n); .)
  [                             (. var n2ret : { n : number } = { n : null }; .)
     ".." Char<n2ret>           (. for (var i = n1ret.n; i <= n2ret.n; i++) { ret.s.Set(i); } .)
  ]
| "ANY"                         (. ret.s = new CharSet(); ret.s.Fill(); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<n : number;>
=
  char                          (. var name = this.t.val; ret.n = '\0'.charCodeAt(0);
                                   name = this.tab.Unescape(name.substring(1, name.length-2));
                                   if (name.length == 1) { ret.n = name[0]; }
                                   else { this.SemErr("unacceptable character value"); }
                                   if (this.dfa.ignoreCase && ret.n >= 'A'.charCodeAt(0) && ret.n <= 'Z'.charCodeAt(0)) ret.n = String.fromCharCode(ret.n).toUpperCase().charCodeAt(0);
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<typ : number;>         (. var symret : { name : string; kind : number } = { name : null, kind : null};
                                    var sym : Symbol; var g : Graph; .)
=
  Sym<symret>                   (. sym = this.tab.FindSym(symret.name);
                                   if (sym != null) { this.SemErr("name declared twice"); }
                                   else {
                                     sym = this.tab.NewSym(ret.typ, symret.name, this.t.line);
                                     sym.tokenKind = Symbol.fixedToken;
                                   }
                                   this.tokenString = null;
                                 .)
  SYNC
  (                             (. var gres : { g: Graph } = { g : g };  .)
	'=' TokenExpr<gres> '.'        (. if (symret.kind == Parser.str) { this.SemErr("a literal must not be declared with a structure"); }
                                   this.tab.Finish(g);
                                   if (this.tokenString == null || this.tokenString == Parser.noString) {
                                     this.dfa.ConvertToStates(g.l, sym);
                                   } else { // TokenExpr is a single string
                                     if (this.tab.literals[this.tokenString] != null) {
                                       this.SemErr("token string declared twice");
                                     }
                                     this.tab.literals[this.tokenString] = sym;
                                     this.dfa.MatchLiteral(this.tokenString, sym);
                                   }
                                 .)
  |                             (. if (symret.kind == Parser.id) { this.genScanner = false; }
                                   else { this.dfa.MatchLiteral(sym.name, sym); }
                                 .)
  )
  [                        (. var retSemPos : { pos : Position } = { pos : null }; .)
	SemText<retSemPos>     (. 
                             sym.semPos = retSemPos.pos;
                             if (ret.typ != Node.pr) { this.SemErr("semantic action not allowed here"); } .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<sym : Symbol;>
=
  '<'                           (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  { ANY
  | badString                   (. this.SemErr("bad string in attributes"); .)
  }
  '>'                           (. if (this.t.pos > beg) {
                                     ret.sym.attrPos = new Position(beg, this.t.pos, col, line); 
                                   } 
								.)
| "<."                          (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  { ANY
  | badString                   (. this.SemErr("bad string in attributes"); .)
  }
  ".>"                          (. if (this.t.pos > beg) {
                                     ret.sym.attrPos = new Position(beg, this.t.pos, col, line); 
                                   } 
								.)
.

/*------------------------------------------------------------------------------------*/

Expression<g : Graph;>
=                             (. var term1 : { g : Graph } = { g : null }; .)
  Term<term1>                 (. ret.g = term1.g; var first = true; .)
  {                             WEAK
    '|'                       (. var term2 : { g : Graph } = { g : null }; .)
    Term<term2>                (. if (first) { this.tab.MakeFirstAlt(ret.g); first = false; }
                                   this.tab.MakeAlternative(ret.g, term2.g);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<g : Graph;>               (. var g2 : Graph; var rslv : Node = null; ret.g = null; .)
=
( [                             (. rslv = this.tab.NewNode(Node.rslv, null, this.la.line);
                                   var rslvpos : { pos : Position } = { pos : null }; 
                                 .)
    Resolver<rslvpos>           (. rslv.pos = rslvpos.pos; ret.g = new Graph(rslv, rslv); .)
  ]
                                (. var factorg2 : { g : Graph } = { g : null }; .)
  Factor<factorg2>              (. g2 = factorg2.g;
                                   if (rslv != null) this.tab.MakeSequence(ret.g, g2);
                                   else ret.g = g2;
                                 .)
  {
    Factor<factorg2>            (. g2 = factorg2.g; this.tab.MakeSequence(ret.g, g2); .)
  }
|                               (. var singleNode = this.tab.NewNode(Node.eps, null, 0);
                                   ret.g = new Graph(singleNode, singleNode); .)
)                               (. if (ret.g == null) { // invalid start of Term
                                     var singleNode = this.tab.NewNode(Node.eps, null, 0);
                                     ret.g = new Graph(singleNode, singleNode);
                                   }
                                 .)
.

/*------------------------------------------------------------------------------------*/

Factor<g : Graph;>             (. var pos : Position; var weak : bool = false; 
                                 ret.g = null;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
                                (. var symret : { name : string; kind : number } = { name : null, kind : null }; .)
  Sym<symret>                   (. var sym = this.tab.FindSym(symret.name);
                                   if (sym == null && symret.kind == Parser.str)
                                     sym = this.tab.literals.get(symret.name);
                                   var undef = sym == null;
                                   if (undef) {
                                     if (symret.kind == Parser.id) {
                                       sym = this.tab.NewSym(Node.nt, symret.name, 0);  // forward nt
                                     } else if (this.genScanner) { 
                                       sym = this.tab.NewSym(Node.t, symret.name, this.t.line);
                                       this.dfa.MatchLiteral(sym.name, sym);
                                     } else {  // undefined string in production
                                       this.SemErr("undefined string in production");
                                       sym = this.tab.eofSy;  // dummy
                                     }
                                   }
                                   var typ = sym.typ;
                                   if (typ != Node.t && typ != Node.nt) {
                                     this.SemErr("this symbol kind is not allowed in a production");
                                   }
                                   if (weak) {
                                     if (typ == Node.t) { typ = Node.wt; }
                                     else { this.SemErr("only terminals may be weak"); }
                                   }
                                   var p = this.tab.NewNode(typ, sym, this.t.line);
                                   ret.g = new Graph(p, p);
                                 .)
  [                             (. var attrp = { p : p }; .)
    Attribs<attrp>              (. if (symret.kind != Parser.id) { this.SemErr("a literal must not have attributes"); } .)
  ]                             (. if (undef) {
                                     sym.attrPos = p.pos;  // dummy
                                   } else if ((p.pos == null) != (sym.attrPos == null)) {
                                     this.SemErr("attribute mismatch between declaration and use of this symbol");
                                   }
								.)
| '(' Expression<ret> ')'
| '[' Expression<ret> ']'     (. this.tab.MakeOption(ret.g); .)
| '{' Expression<ret> '}'     (. this.tab.MakeIteration(ret.g); .)
|                               (. var retSemPos : { pos : Position } = { pos : null }; .)
   SemText<retSemPos>           (. pos = retSemPos.pos;
                                   var p = this.tab.NewNode(Node.sem, null, 0);
                                   p.pos = pos;
                                   ret.g = new Graph(p, p);
                                 .)
| "ANY"                         (. var p = this.tab.NewNode(Node.any, null, 0);  // p.set is set in this.tab.SetupAnys
                                   ret.g = new Graph(p, p);
                                 .)
| "SYNC"                        (. var p = this.tab.NewNode(Node.sync, null, 0);
                                   ret.g = new Graph(p, p);
                                 .)
)                               (. if (ret.g == null) {// invalid start of Factor
                                     var nullnode = this.tab.NewNode(Node.eps, null, 0);
                                     ret.g = new Graph(nullnode, nullnode);
                                   }.)
.

/*------------------------------------------------------------------------------------*/

Resolver<pos : Position;>
=
  "IF" "("                       (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  Condition                      (. ret.pos = new Position(beg, this.t.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<g : Graph;>            (. var g2 : Graph; .)
=                               (. var tokentermg : { g : Graph } = { g : null }; .)
  TokenTerm<tokentermg>         (. ret.g = tokentermg.g; var first = true; .)
  {                             WEAK
    '|'
    TokenTerm<tokentermg>      (. g2 = tokentermg.g;
                                   if (first) { this.tab.MakeFirstAlt(ret.g); first = false; }
                                   this.tab.MakeAlternative(ret.g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<g: Graph;>          (. var g2 : Graph; .)
=                             (. var tokenfactorg : { g : Graph } = { g : null}; .)
  TokenFactor<tokenfactorg>     (. ret.g = tokenfactorg.g; .)
  {  TokenFactor<tokenfactorg>  (. g2 = tokenfactorg.g; 
                                   this.tab.MakeSequence(ret.g, g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<tokenfactorg>    (. g2 = tokenfactorg.g; 
                                     this.tab.SetContextTrans(g2.l); this.dfa.hasCtxMoves = true;
                                     this.tab.MakeSequence(ret.g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<g : Graph;>        (. .)
=
                                (. ret.g = null; .)
(                               (. var sym : { name : string; kind : number } = { name : "", kind : -1 }; .)
  Sym<sym>                      (. if (sym.kind == Parser.id) {
                                     var c = this.tab.FindCharClass(sym.name);
                                     if (c == null) {
                                       this.SemErr("undefined name");
                                       c = this.tab.NewCharClass(sym.name, new CharSet());
                                     }
                                     var p = this.tab.NewNode(Node.clas, null, 0); 
                                     p.val = c.n;
                                     ret.g = new Graph(p, p);
                                     this.tokenString = Parser.noString;
                                   } else { // str
                                     ret.g = this.tab.StrToGraph(sym.name);
                                     if (this.tokenString == null) this.tokenString = sym.name;
                                     else this.tokenString = Parser.noString;
                                   }
                                 .)
|                                      (. var tokenexpr : { g: Graph} = {g : null}; .)
	'(' TokenExpr<tokenexpr> ')'      (. ret.g = tokenexpr.g; .)
| '[' TokenExpr<tokenexpr> ']'      (. ret.g = tokenexpr.g; this.tab.MakeOption(ret.g); this.tokenString = Parser.noString; .)
| '{' TokenExpr<tokenexpr> '}'      (. ret.g = tokenexpr.g; this.tab.MakeIteration(ret.g); this.tokenString = Parser.noString; .)
)                                    (. if (ret.g == null) { // invalid start of TokenFactor
                                        var nullnode = this.tab.NewNode(Node.eps, null, 0);
                                        ret.g = new Graph(nullnode, nullnode); 
                                   } .)
.

/*------------------------------------------------------------------------------------*/

Sym<name : string; kind : number;>
=                               (. ret.name = "???"; ret.kind = Parser.id; .)
( ident                         (. ret.kind = Parser.id; ret.name = this.t.val; .)
| (string                       (. ret.name = this.t.val; .)
  | char                        (. ret.name = "\"" + this.t.val.substring(1, this.t.val.length-2) + "\""; .)
  )                             (. ret.kind = Parser.str;
                                   if (this.dfa.ignoreCase) ret.name = ret.name.toLowerCase();
                                   if (ret.name.indexOf(' ') >= 0)
                                     this.SemErr("literal tokens must not contain blanks"); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<p : Node;>          // TODO: in argument!!
=
  '<'                           (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  { ANY 
  | badString                   (. this.SemErr("bad string in attributes"); .)
  }
  '>'                           (. if (this.t.pos > beg) ret.p.pos = new Position(beg, this.t.pos, col, line); .)
| "<."                          (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  { ANY 
  | badString                   (. this.SemErr("bad string in attributes"); .)
  }
  ".>"                          (. if (this.t.pos > beg) ret.p.pos = new Position(beg, this.t.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

SemText<pos : Position;>
=
  "(."                          (. var beg = this.la.pos; var col = this.la.col; var line = this.la.line; .)
  { ANY
  | badString                   (. this.SemErr("bad string in semantic action"); .)
  | "(."                        (. this.SemErr("missing end of previous semantic action"); .)
  }
  ".)"                          (. ret.pos = new Position(beg, this.t.pos, col, line); .)
.

END Coco.
