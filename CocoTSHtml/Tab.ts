/*-------------------------------------------------------------------------
Tab.cs -- Symbol Table Management
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/// <reference path="Parser.ts" />

module at.jku.ssw.Coco {

export class Position {  // position of source code stretch (e.g. semantic action, resolver expressions)
	private _beg : number;      // start relative to the beginning of the file
	private _end : number;      // end of stretch
	private _col : number;      // column number of start position
	private _line : number;     // line number of start position

	public Position(beg : number, end : number, col : number, line : number) {
		this._beg = beg;
		this._end = end;
		this._col = col;
		this._line = line;
	}
	get beg() { return this._beg; }
	get end() { return this._end; }
	get col() { return this._col; }
	get line() { return this._line; }
}


//=====================================================================
// Symbol
//=====================================================================

export class Symbol {

// token kinds
	public static get fixedToken(): number { return 0; } // e.g. 'a' ('b' | 'c') (structure of literals)
	public static get classToken(): number { return 1; } 	// e.g. digit {digit}   (at least one char class)
	public static get litToken(): number { return 2; } // e.g. "while"
	public static get classLitToken(): number { return 3; } // e.g. letter {letter} but without literals that have the same structure

	public n : number;           // symbol number
	public typ : number;         // t, nt, pr, unknown, rslv /* ML 29_11_2002 slv added */ /* AW slv --> rslv */
	public name : string;        // symbol name
	public graph: Node;       // nt: to first node of syntax graph
	public tokenKind : number;   // t:  token kind (fixedToken, classToken, ...)
	public deletable: bool;   // nt: true if nonterminal is deletable
	public firstReady: bool;  // nt: true if terminal start symbols have already been computed
	public first: BitArray;       // nt: terminal start symbols
	public follow: BitArray;      // nt: terminal followers
	public nts: BitArray;         // nt: nonterminals whose followers have to be added to this sym
	public line : number;        // source text line number of item in this node
	public attrPos: Position;     // nt: position of attributes in source text (or null)
	public semPos: Position;      // pr: pos of semantic action in source text (or null)
// nt: pos of local declarations in source text (or null)

	constructor(typ : number, name : string, line : number) {
		this.typ = typ;
		this.name = name;
		this.line = line;
	}
}


//=====================================================================
// Node
//=====================================================================

export class Node {
// constants for node kinds
	public static get t(): number { return 1; }  // terminal symbol
	public static get pr(): number { return   2; } // pragma
	public static get nt(): number { return   3; } // nonterminal symbol
	public static get clas(): number { return   4; } // character class
	public static get chr(): number { return   5; } // character
	public static get wt(): number { return   6; } // weak terminal symbol
	public static get any(): number { return   7; } // 
	public static get eps(): number { return   8; } // empty
	public static get sync(): number { return   9; } // synchronization symbol
	public static get sem(): number { return  10; } // semantic action: (. .)
	public static get alt(): number { return  11; } // alternative: |
	public static get iter(): number { return  12; } // iteration: { }
	public static get opt(): number { return  13; } // option: [ ]
	public static get rslv(): number { return 14; } // resolver expr

	public static get normalTrans(): number { return 0; }	// transition codes
	public static get contextTrans(): number { return 1; }

	public n : number;			// node number
	public typ : number;		// t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
	public next: Node;		// to successor node
	public down: Node;		// alt: to next alternative
	public sub: Node;		// alt, iter, opt: to first node of substructure
	public up : bool;			// true: "next" leads to successor in enclosing structure
	public sym: Symbol;		// nt, t, wt: symbol represented by this node
	public val : number;		// chr:  ordinal character value
// clas: index of character class
	public code : number;		// chr, clas: transition code
	public set: BitArray;		// any, sync: the set represented by this node
	public pos: Position;		// nt, t, wt: pos of actual attributes
// sem:       pos of semantic action in source text
// rslv:       pos of resolver in source text
	public line : number;		// source text line number of item in this node
	public state: State;	// DFA state corresponding to this node
// (only used in DFA.ConvertToStates)

	constructor(typ: number, sym: Symbol, line : number) {
		this.typ = typ;
		this.sym = sym;
		this.line = line;
	}
}

//=====================================================================
// Graph 
//=====================================================================

export class Graph {
	public l : Node;	// left end of graph = head
	public r : Node;	// right end of graph = list of nodes to be linked to successor graph
	
	constructor(left: Node, right: Node) {
		this.l = left;
		this.r = right;
	}

/*	constructor(p: Node) {
		l = p; r = p;
	}*/
}

class CNode {	// node of list for finding circular productions
	public left: Symbol;
	public right: Symbol;

	constructor(l: Symbol, r: Symbol) {
		this.left = l;
		this.right = r;
	}
}

//=====================================================================
// Sets 
//=====================================================================

export class Sets {

	public static Elements(s: BitArray) : number {
		var max = s.Count;
		var n = 0;
		for (var i=0; i<max; i++)
			if (s[i]) n++;
		return n;
	}

	public static Equals(a: BitArray, b: BitArray): bool {
		var max = a.Count;
		for (var i = 0; i<max; i++)
			if (a[i] != b[i])
				return false;
		return true;
	}

	public static Intersect(a: BitArray, b: BitArray): bool  { // a * b != {}
		var max = a.Count;
		for (var i=0; i<max; i++)
			if (a[i] && b[i]) return true;
		return false;
	}

	public static Subtract(a: BitArray, b: BitArray) { // a = a - b
		var c = b.Clone();
		a.And(c.Not());
	}
}

//=====================================================================
// CharClass
//=====================================================================

export class CharClass {
	public n : number;       	// class number
	public name: string;		// class name
	public set: CharSet;	// set representing the class

	constructor(name: string, s: CharSet) {
		this.name = name;
		this.set = s;
	}
}


//=====================================================================
// Tab
//=====================================================================
export class Tab {
	public semDeclPos: Position;       // position of global semantic declarations
	public ignored: CharSet;           // characters ignored by the scanner
	public ddt: bool[] = new Array(10); // debug and test switches
	public gramSy : Symbol;            // root nonterminal; filled by ATG
	public eofSy: Symbol;              // end of file symbol
	public noSym: Symbol;              // used in case of an error
	public allSyncSets: BitArray;      // union of all synchronisation sets
	public literals: Hashtable;        // symbols that are used as literals

	public srcName: string;            // name of the atg file (including path)
	public srcDir: string;             // directory path of the atg file
	public nsName: string;             // namespace for generated files
	public frameDir: string;           // directory containing the frame files
	public outDir: string;             // directory for generated files
	public checkEOF: bool = true;      // should coco generate a check for EOF at
//   the end of Parser.Parse():
	public emitLines: bool;            // emit #line pragmas for semantic actions
//   in the generated parser

	visited: BitArray;                 // mark list for graph traversals
	curSy: Symbol;                     // current symbol in computation of sets

	parser: Parser;                    // other Coco objects
	trace: TextWriter;
	errors: Errors;

	constructor(parser: Parser) {
		this.parser = parser;
		this.trace = this.parser.trace;
		this.errors = this.parser.errors;
		this.eofSy = this.NewSym(Node.t, "EOF", 0);
		this.dummyNode = this.NewNode(Node.eps, null, 0);
		this.literals = new Hashtable();
	}

//---------------------------------------------------------------------
//  Symbol list management
//---------------------------------------------------------------------

	public terminals: Symbol[] = []; // Symbol
	public pragmas: Symbol[] = []; // Symbol
	public nonterminals: Symbol[]= []; // Symbol

	tKind: string[]= ["fixedToken", "classToken", "litToken", "classLitToken"];

	public NewSym(typ: number, name: string, line: number): Symbol {
		if (name.length == 2 && name[0]== '"') {
			this.parser.SemErr("empty token not allowed");
			name = "???";
		}

		var sym= new Symbol(typ, name, line);
		switch (typ) {
			case Node.t: sym.n = this.terminals.length; this.terminals.push(sym); break;
			case Node.pr: this.pragmas.push(sym); break;
			case Node.nt: sym.n = this.nonterminals.length; this.nonterminals.push(sym); break;
		}
		return sym;
	}

	public FindSym(name: string): Symbol  {
		for(var i = 0; i < this.terminals.length; i++) {
			var s = this.terminals[i];
			if (s.name == name) return s;
		}
		for(var i = 0; i < this.nonterminals.length; i++) {
			var s = this.nonterminals[i];
			if (s.name == name) return s;
		}

		return null;
	}

	Num(p: Node) : number{
		if (p == null) return 0; else return p.n;
	}

	PrintSym(sym: Symbol) {
		this.trace.WriteFormatted3("{0,3} {1,-14} {2}", sym.n, this.Name(sym.name), this.nTyp[sym.typ]);
		if (sym.attrPos == null) {
			this.trace.Write(" false ");
		} else {
			this.trace.Write(" true  ");
		}

		if (sym.typ == Node.nt) {
			this.trace.WriteFormatted1("{0,5}", this.Num(sym.graph));
			if (sym.deletable) {
				this.trace.Write(" true  ");
			} else {
				this.trace.Write(" false ");
			}
		} else {
			this.trace.Write("            ");
		}

		this.trace.WriteLineFormatted2("{0,5} {1}", sym.line, this.tKind[sym.tokenKind]);
	}

	public PrintSymbolTable() {
		this.trace.WriteLineText("Symbol Table:");
		this.trace.WriteLineText("------------");
		this.trace.WriteLine();
		this.trace.WriteLineText(" nr name          typ  hasAt graph  del    line tokenKind");
		for(var i = 0; i < this.terminals.length; i++) { this.PrintSym(this.terminals[i]); }
		for(var i = 0; i < this.pragmas.length; i++) { this.PrintSym(this.pragmas[i]); }
		for(var i = 0; i < this.nonterminals.length; i++) { this.PrintSym(this.nonterminals[i]); }
		this.trace.WriteLine();
		this.trace.WriteLineText("Literal Tokens:");
		this.trace.WriteLineText("--------------");
		for(var i = 0; i < this.literals.length; i++) {
			var e = this.literals[i];
			this.trace.WriteLineText("_" + e.Value.name + " = " +e.Key + ".");
		}
		this.trace.WriteLine();
	}

	public PrintSet(s: BitArray, indent : number) {
		var col: number;
		var len : number;
		col = indent;
		for(var i = 0; i < this.terminals.length; i++) {
			var sym = this.terminals[i];
			if (s[sym.n]) {
				len = sym.name.length;
				if (col +len >= 80) {
					this.trace.WriteLine();
					for (col = 1; col < indent; col++) this.trace.Write(" ");
				}

				this.trace.WriteFormatted1("{0} ", sym.name);
				col += len +1;
			}
		}

		if (col == indent) {
			this.trace.Write("-- empty set --");
		}
		this.trace.WriteLine();
	}

//---------------------------------------------------------------------
//  Syntax graph management
//---------------------------------------------------------------------

	public nodes : Node[] = [];
	public nTyp: string[] =
		["    ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ",
		 "sync", "sem ", "alt ", "iter", "opt ", "rslv"];
	dummyNode: Node;

	public NewNode(typ: number, sym: Symbol, line : number): Node  {
		var node = new Node(typ, sym, line);
		node.n = this.nodes.length;
		this.nodes.push(node);
		return node;
	}

	public NewNodeTypeSubNode(typ: number, sub: Node): Node  {
		var node = this.NewNode(typ, null, 0);
		node.sub = sub;
		return node;
	}

/*
	public NewNode(typ : number, val : number, line : number): Node {
		var node = NewNode(typ, null, line);
		node.val = val;
		return node;
	}
*/
	public MakeFirstAlt(g: Graph) {
		g.l = this.NewNodeTypeSubNode(Node.alt, g.l);
		g.l.line = g.l.sub.line;
		g.r.up = true;
		g.l.next = g.r;
		g.r = g.l;
	}

// The result will be in g1
	public MakeAlternative(g1: Graph, g2: Graph) {
		g2.l = this.NewNodeTypeSubNode(Node.alt, g2.l);
		g2.l.line = g2.l.sub.line;
		g2.l.up = true;
		g2.r.up = true;
		var p = g1.l; while (p.down != null) p = p.down;
		p.down = g2.l;
		p = g1.r; while (p.next != null) p = p.next;
// append alternative to g1 end list
		p.next = g2.l;
// append g2 end list to g1 end list
		g2.l.next = g2.r;
	}

// The result will be in g1
	public MakeSequence(g1: Graph, g2: Graph) {
		var p = g1.r.next;
		g1.r.next = g2.l; // link head node
		while (p != null) {  // link substructure
			var q = p.next; p.next = g2.l;
			p = q;
		}
		g1.r = g2.r;
	}

	public MakeIteration(g: Graph) {
		g.l = this.NewNodeTypeSubNode(Node.iter, g.l);
		g.r.up = true;
		var p = g.r;
		g.r = g.l;
		while (p != null) {
			var q = p.next; p.next = g.l;
			p = q;
		}
	}

	public MakeOption(g: Graph) {
		g.l = this.NewNodeTypeSubNode(Node.opt, g.l);
		g.r.up = true;
		g.l.next = g.r;
		g.r = g.l;
	}

	public Finish(g: Graph) {
		var p = g.r;
		while (p != null) {
			var q = p.next;
			p.next = null;
			p = q;
		}
	}

	public DeleteNodes() {
		this.nodes = [];
		this.dummyNode = this.NewNode(Node.eps, null, 0);
	}

	public StrToGraph(str: string): Graph  {
		var s = this.Unescape(str.substring(1, str.length-2));
		if (s.length == 0) this.parser.SemErr("empty token not allowed");
		var g = new Graph(null, null);
		g.r = this.dummyNode;
		for (var i = 0; i < s.length; i++) {
			var p = this.NewNode(Node.chr, s[i], 0);
			g.r.next = p; g.r = p;
		}

		g.l = this.dummyNode.next; this.dummyNode.next = null;
		return g;
	}

	public SetContextTrans(p: Node) { // set transition code in the graph rooted at p
		while (p != null) {
			if (p.typ == Node.chr || p.typ == Node.clas) {
				p.code = Node.contextTrans;
			} else if (p.typ == Node.opt || p.typ == Node.iter) {
				this.SetContextTrans(p.sub);
			} else if (p.typ == Node.alt) {
				this.SetContextTrans(p.sub);
				this.SetContextTrans(p.down);
			}

			if (p.up)
				break;
			p = p.next;
		}
	}

//------------ graph deletability check -----------------

	public static DelGraph(p: Node): bool {
		return p == null || Tab.DelNode(p) && Tab.DelGraph(p.next);
	}

	public static DelSubGraph(p: Node): bool  {
		return p == null || Tab.DelNode(p) && (p.up || Tab.DelSubGraph(p.next));
	}

	public static DelNode(p: Node): bool {
		if (p.typ == Node.nt) {
			return p.sym.deletable;
		} else if (p.typ == Node.alt) {
			return Tab.DelSubGraph(p.sub) || p.down != null && Tab.DelSubGraph(p.down);
		} else {
			return p.typ == Node.iter || p.typ == Node.opt || p.typ == Node.sem
				|| p.typ == Node.eps || p.typ == Node.rslv || p.typ == Node.sync;
		}
	}

//----------------- graph printing ----------------------

	Ptr(p: Node, up: bool): string  {
		var ptr = (p == null)? "0": p.n.toString();
		return (up)? ("-" +ptr): ptr;
	}

	static Format(formatString: string, o1: any): string{
		// TODO
		return null;
	}

	Pos(pos: Position): string  {
		if (pos == null) {
			return "     ";
		} else {
			return Tab.Format("{0,5}", pos.beg);
		}
	}

	public Name(name: string): string {
		return (name + "           ").substring(0, 12);
		// found no simpler way to get the first 12 characters of the name
		// padded with blanks on the right
	}

	public PrintNodes() {
		this.trace.WriteLineText("Graph nodes:");
		this.trace.WriteLineText("----------------------------------------------------");
		this.trace.WriteLineText("   n type name          next  down   sub   pos  line");
		this.trace.WriteLineText("                               val  code");
		this.trace.WriteLineText("----------------------------------------------------");
		for (var i = 0; i < this.nodes.length; i++) {
			var p = this.nodes[i];
			this.trace.WriteFormatted2("{0,4} {1} ", p.n, this.nTyp[p.typ]);
			if (p.sym != null) {
				this.trace.WriteFormatted1("{0,12} ", this.Name(p.sym.name));
			} else if (p.typ == Node.clas) {
				var c = this.classes[p.val];
				this.trace.WriteFormatted1("{0,12} ", this.Name(c.name));
			} else {
				this.trace.Write("             ");
			}

			this.trace.WriteFormatted1("{0,5} ", this.Ptr(p.next, p.up));
			switch (p.typ) {
				case Node.t: case Node.nt: case Node.wt:
					this.trace.WriteFormatted1("             {0,5}", this.Pos(p.pos)); break;
				case Node.chr:
					this.trace.WriteFormatted2("{0,5} {1,5}       ", p.val, p.code); break;
				case Node.clas:
					this.trace.WriteFormatted1("      {0,5}       ", p.code); break;
				case Node.alt: case Node.iter: case Node.opt:
					this.trace.WriteFormatted2("{0,5} {1,5}       ", this.Ptr(p.down, false), this.Ptr(p.sub, false)); break;
				case Node.sem:
					this.trace.WriteFormatted1("             {0,5}", this.Pos(p.pos)); break;
				case Node.eps: case Node.any: case Node.sync:
					this.trace.Write("                  "); break;
			}

			this.trace.WriteLineFormatted1("{0,5}", p.line);
		}
		this.trace.WriteLine();
	}


//---------------------------------------------------------------------
//  Character class management
//---------------------------------------------------------------------

	public classes : CharClass[] = [];
	public dummyName = 'A'.charCodeAt(0);

	public NewCharClass(name: string, s: CharSet): CharClass {
		if (name == "#") {
			name = "#" + String.fromCharCode(this.dummyName++);
		}

		var c = new CharClass(name, s);
		c.n = this.classes.length;
		this.classes.push(c);
		return c;
	}

	public FindCharClass(name: string): CharClass  {
		for(var i = 0; i < this.classes.length; i++) {
			var c = this.classes[i];
			if (c.name == name) return c;
		}

		return null;
	}

	public FindCharClassCS(s: CharSet): CharClass  {
		for(var i = 0; i < this.classes.length; i++) {
			var c = this.classes[i];
			if (s.Equals(c.set )) return c;
		}
		return null;
	}

	public CharClassSet(i: number): CharSet  {
		return this.classes[i].set;
	}

	//----------- character class printing

	static Ch(ch: number): string {
		if (ch < ' '.charCodeAt(0) ||
			ch >= 127 ||
			ch == '\''.charCodeAt(0) ||
			ch == '\\'.charCodeAt(0)) return String.fromCharCode(ch);
		else return "'\\u" + ch.toString(16) + "'";
	}

	WriteCharSet(s: CharSet) {
		for (var r = s.head; r != null; r = r.next) {
			if (r.from < r.to) {
				this.trace.Write(Tab.Ch(r.from) + ".." + Tab.Ch(r.to) + " ");
			} else {
				this.trace.Write(Tab.Ch(r.from) + " ");
			}
		}
	}

	public WriteCharClasses () {
		for(var i = 0; i < this.classes.length; i++) {
			var c = this.classes[i];
			this.trace.WriteFormatted1("{0,-10}: ", c.name);
			this.WriteCharSet(c.set);
			this.trace.WriteLine();
		}

		this.trace.WriteLine();
	}


//---------------------------------------------------------------------
//  Symbol set computations
//---------------------------------------------------------------------

/* Computes the first set for the graph rooted at p */
	First0(p: Node, mark: BitArray): BitArray {
		var fs = new BitArray(this.terminals.length, false);
		while (p != null && !mark[p.n]) {
			mark[p.n]= true;
			switch (p.typ) {
				case Node.nt: {
					if (p.sym.firstReady) {
						fs.Or(p.sym.first);
					} else {
						fs.Or(this.First0(p.sym.graph, mark));
					}
					break;
				}
				case Node.t: case Node.wt: {
					fs[p.sym.n]= true; break;
				}
				case Node.any: {
					fs.Or(p.set ); break;
				}
				case Node.alt: {
					fs.Or(this.First0(p.sub, mark));
					fs.Or(this.First0(p.down, mark));
					break;
				}
				case Node.iter: case Node.opt: {
					fs.Or(this.First0(p.sub, mark));
					break;
				}
			}
			if (!Tab.DelNode(p))
				break;
			p = p.next;
		}
		return fs;
	}

	public First(p: Node): BitArray  {
		var fs = this.First0(p, new BitArray(this.nodes.length, false));
		if (this.ddt[3]) {
			this.trace.WriteLine();
			if (p != null) {
				this.trace.WriteLineFormatted1("First: node = {0}", p.n);
			} else {
				this.trace.WriteLineText("First: node = null");
			}

			this.PrintSet(fs, 0);
		}
		return fs;
	}

	CompFirstSets() {
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			sym.first = new BitArray(this.terminals.length, false);
			sym.firstReady = false;
		}
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			sym.first = this.First(sym.graph);
			sym.firstReady = true;
		}
	}

	CompFollow(p: Node) {
		while (p != null && !this.visited[p.n]) {
			this.visited[p.n]= true;
			if (p.typ == Node.nt) {
				var s = this.First(p.next);
				p.sym.follow.Or(s);
				if (Tab.DelGraph(p.next))
				{
					p.sym.nts[this.curSy.n] = true;
				}
			} else if (p.typ == Node.opt || p.typ == Node.iter) {
				this.CompFollow(p.sub);
			} else if (p.typ == Node.alt) {
				this.CompFollow(p.sub);
				this.CompFollow(p.down);
			}
			p = p.next;
		}
	}

	Complete(sym: Symbol) {
		if (!this.visited[sym.n]) {
			this.visited[sym.n]= true;
			for(var i = 0; i < this.nonterminals.length; i++) {
				var s = this.nonterminals[i];
				if (sym.nts[s.n]) {
					this.Complete(s);
					sym.follow.Or(s.follow);
					if (sym == this.curSy) {
						sym.nts[s.n] = false;
					}
				}
			}
		}
	}

	CompFollowSets() {
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			sym.follow = new BitArray(this.terminals.length, false);
			sym.nts = new BitArray(this.nonterminals.length, false);
		}

		this.gramSy.follow[this.eofSy.n] = true;
		this.visited = new BitArray(this.nodes.length, false);
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			this.curSy = sym;
			this.CompFollow(sym.graph);
		}

		// add indirect successors to followers
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			this.visited = new BitArray(this.nonterminals.length, false);
			this.curSy = sym;
			this.Complete(sym);
		}
	}

	LeadingAny(p: Node): Node {
		if (p == null) {
			return null;
		}

		var a: Node = null;
		if (p.typ == Node.any) {
			a = p;
		}
		else if (p.typ == Node.alt) {
			a = this.LeadingAny(p.sub);
			if (a == null) {
				a = this.LeadingAny(p.down);
			}
		}
		else if (p.typ == Node.opt || p.typ == Node.iter) {
			a = this.LeadingAny(p.sub);
		}

		if (a == null && Tab.DelNode(p) && !p.up) {
			a = this.LeadingAny(p.next);
		}

		return a;
	}

	FindAS(p: Node) { // find ANY sets
		var a: Node;
		while (p != null) {
			if (p.typ == Node.opt || p.typ == Node.iter) {
				this.FindAS(p.sub);
				a = this.LeadingAny(p.sub);
				if (a != null) {
					Sets.Subtract(a.set , this.First(p.next));
				}
			} else if (p.typ == Node.alt) {
				var s1 = new BitArray(this.terminals.length, false);
				var q = p;
				while (q != null) {
					this.FindAS(q.sub);
					a = this.LeadingAny(q.sub);
					if (a != null) {
						Sets.Subtract(a.set, this.First(q.down).Or(s1));
					} else {
						s1.Or(this.First(q.sub));
					}
					q = q.down;
				}
			}

			// Remove alternative terminals before ANY, in the following
			// examples a and b must be removed from the ANY set:
			// [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
			// A = [a]. A ANY
			if (Tab.DelNode(p)) {
				a = this.LeadingAny(p.next);
				if (a != null) {
					var q = (p.typ == Node.nt)? p.sym.graph: p.sub;
					Sets.Subtract(a.set , this.First(q));
				}
			}

			if (p.up) {
				break;
			}

			p = p.next;
		}
	}

	CompAnySets() {
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			this.FindAS(sym.graph);
		}
	}

	public Expected(p: Node, curSy: Symbol): BitArray {
		var s = this.First(p);
		if (Tab.DelGraph(p)) {
			s.Or(curSy.follow);
		}
		return s;
	}

	// does not look behind resolvers; only called during LL(1) test and in CheckRes
	public Expected0(p: Node, curSy: Symbol): BitArray {
		if (p.typ == Node.rslv) {
			return new BitArray(this.terminals.length, false);
		} else {
			return this.Expected(p, curSy);
		}
	}

	CompSync(p: Node) {
		while (p != null && !this.visited[p.n]) {
			this.visited[p.n]= true;
			if (p.typ == Node.sync) {
				var s = this.Expected(p.next, this.curSy);
				s[this.eofSy.n]= true;
				this.allSyncSets.Or(s);
				p.set = s;
			} else if (p.typ == Node.alt) {
				this.CompSync(p.sub);
				this.CompSync(p.down);
			} else if (p.typ == Node.opt || p.typ == Node.iter) {
				this.CompSync(p.sub);
			}
			p = p.next;
		}
	}

	CompSyncSets() {
		this.allSyncSets = new BitArray(this.terminals.length, false);
		this.allSyncSets[this.eofSy.n]= true;
		this.visited = new BitArray(this.nodes.length, false);
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			this.curSy = sym;
			this.CompSync(this.curSy.graph);
		}
	}

	public SetupAnys() {
		for(var i = 0; i < this.nodes.length; i++) {
			var p = this.nodes[i];
			if (p.typ == Node.any) {
				p.set = new BitArray(this.terminals.length, true);
				p.set [this.eofSy.n] = false;
			}
		}
	}

	public CompDeletableSymbols() {
		var changed: bool;
		do {
			changed = false;
			for(var i = 0; i < this.nonterminals.length; i++) {
				var sym = this.nonterminals[i];
				if (!sym.deletable && sym.graph != null && Tab.DelGraph(sym.graph)) {
					sym.deletable = true; changed = true;
				}
			}
		} while (changed);
		
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			if (sym.deletable) {
				this.errors.Warning("  " +sym.name + " deletable");
			}
		}
	}

	public RenumberPragmas() {
		var n = this.terminals.length;
		for(var i = 0; i < this.pragmas.length; i++) {
			var sym = this.pragmas[i];
			sym.n = n++;
		}
	}

	public CompSymbolSets() {
		this.CompDeletableSymbols();
		this.CompFirstSets();
		this.CompAnySets();
		this.CompFollowSets();
		this.CompSyncSets();
		if (this.ddt[1]) {
			this.trace.WriteLine();
			this.trace.WriteLineText("First & follow symbols:");
			this.trace.WriteLineText("----------------------");
			this.trace.WriteLine();
			for(var i = 0; i < this.nonterminals.length; i++) {
				var sym = this.nonterminals[i];
				this.trace.WriteLineText(sym.name);
				this.trace.Write("first:   ");
				this.PrintSet(sym.first, 10);
				this.trace.Write("follow:  ");
				this.PrintSet(sym.follow, 10);
				this.trace.WriteLine();
			}
		}
		if (this.ddt[4]) {
			this.trace.WriteLine();
			this.trace.WriteLineText("ANY and SYNC sets:");
			this.trace.WriteLineText("-----------------");
			for(var i = 0; i < this.nodes.length; i++) {
				var p = this.nodes[i];
				if (p.typ == Node.any || p.typ == Node.sync) {
					this.trace.WriteFormatted2("{0,4} {1,4}: ", p.n, this.nTyp[p.typ]);
					this.PrintSet(p.set , 11);
				}
			}
		}
	}

//---------------------------------------------------------------------
//  String handling
//---------------------------------------------------------------------

	Hex2Char(s: string) : string {
		return String.fromCharCode(parseInt(s, 16));
	}

	Char2Hex(ch: number): string {
		//w.WriteFormatted1("\\u{0:x4}", ch);
		
		return "\\u" + ch.toString(16);
	}

	public Unescape(s: string): string {
		/* replaces escape sequences in s by their Unicode values. */
		var buf = new StringBuilder("");
		var i = 0;
		while (i < s.length) {
			if (s[i]== '\\') {
				switch (s[i+1]) {
					case '\\': buf.append('\\'); i += 2; break;
					case '\'': buf.append('\''); i += 2; break;
					case '\"': buf.append('\"'); i += 2; break;
					case 'r': buf.append('\r'); i += 2; break;
					case 'n': buf.append('\n'); i += 2; break;
					case 't': buf.append('\t'); i += 2; break;
					case '0': buf.append('\0'); i += 2; break;
					case 'a': buf.append('\a'); i += 2; break;
					case 'b': buf.append('\b'); i += 2; break;
					case 'f': buf.append('\f'); i += 2; break;
					case 'v': buf.append('\v'); i += 2; break;
					case 'u': case 'x':
						if (i +6 <= s.length) {
							buf.append(this.Hex2Char(s.substring(i + 2, 4)));
							i += 6;
							break;
						} else {
							this.parser.SemErr("bad escape sequence in string or character");
							i = s.length;
							break;
						}
					default:
						this.parser.SemErr("bad escape sequence in string or character");
						i += 2;
						break;
				}
			} else {
				buf.append(s[i]);
				i++;
			}
		}

		return buf.toString();
	}

	public Escape(s: string): string {
		var buf = new StringBuilder("");
		for (var i = 0; i < s.length; i++) {
			var ch = s.charCodeAt(i);
			switch(ch) {
				case '\\'.charCodeAt(0): buf.append("\\\\"); break;
				case '\''.charCodeAt(0): buf.append("\\'"); break;
				case '\"'.charCodeAt(0): buf.append("\\\""); break;
				case '\t'.charCodeAt(0): buf.append("\\t"); break;
				case '\r'.charCodeAt(0): buf.append("\\r"); break;
				case '\n'.charCodeAt(0): buf.append("\\n"); break;
				default:
					if (ch < ' '.charCodeAt(0) || ch > '\u007f'.charCodeAt(0)) {
						buf.append(this.Char2Hex(ch));
					} else {
						buf.append(String.fromCharCode(ch));
					}
					break;
			}
		}

		return buf.toString();
	}

//---------------------------------------------------------------------
//  Grammar checks
//---------------------------------------------------------------------

	public GrammarOk(): bool {
		var ok = this.NtsComplete()
			&& this.AllNtReached()
			&& this.NoCircularProductions()
			&& this.AllNtToTerm();
		if (ok) {
			this.CheckResolvers();
			this.CheckLL1();
		}

		return ok;
	}

//--------------- check for circular productions ----------------------

	GetSingles(p: Node, singles: Symbol[]) {
		if (p == null) {
			return;  // end of graph
		}
		if (p.typ == Node.nt) {
			if (p.up || Tab.DelGraph(p.next)) {
				singles.push(p.sym);
			}
		} else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt) {
			if (p.up || Tab.DelGraph(p.next)) {
				this.GetSingles(p.sub, singles);
				if (p.typ == Node.alt) {
					this.GetSingles(p.down, singles);
				}
			}
		}
		if (!p.up && Tab.DelNode(p)) {
			this.GetSingles(p.next, singles);
		}
	}

	public NoCircularProductions(): bool {
		var ok: bool;
		var changed: bool;
		var onLeftSide: bool;
		var onRightSide: bool;
		var list: CNode[] = [];
		this.nonterminals.forEach(function (sym: Symbol) {
			var singles: Symbol[] = [];
			this.GetSingles(sym.graph, singles); // get nonterminals s such that sym-->s
			
			singles.forEach(function (s) {
				list.push(new CNode(sym, s));
			});
		});

		do {
			changed = false;
			for (var i = 0; i < list.length; i++) {
				var n = list[i];
				onLeftSide = false;
				onRightSide = false;
				
				list.forEach(function (m) {
					if (n.left == m.right) onRightSide = true;
					if (n.right == m.left) onLeftSide = true;
				});

				if (!onLeftSide || !onRightSide) {
					list.splice(i, 1);
					i--;
					changed = true;
				}
			}
		} while(changed);
		ok = true;
		list.forEach(function (n) {
			ok = false;
			this.errors.SemErr("  " + n.left.name + " --> " + n.right.name);
		});

		return ok;
	}

//--------------- check for LL(1) errors ----------------------

	LL1Error(cond: number, sym: Symbol) {
		var s = "  LL1 warning in " + this.curSy.name + ": ";
		if (sym != null) {
			s += sym.name + " is ";
		}

		switch (cond) {
			case 1: s += "start of several alternatives"; break;
			case 2: s += "start & successor of deletable structure"; break;
			case 3: s += "an ANY node that matches no symbol"; break;
			case 4: s += "contents of [...] or {...} must not be deletable"; break;
		}
		this.errors.Warning(s);
	}

	CheckOverlap(s1: BitArray, s2: BitArray, cond: number) {
		var outer = this;
		this.terminals.forEach(function (sym) {
			if (s1[sym.n] && s2[sym.n]) {
				outer.LL1Error(cond, sym);
			}
		});
	}

	CheckAlts(p: Node) {
		var s1: BitArray;
		var s2: BitArray;
		while (p != null) {
			if (p.typ == Node.alt) {
				var q = p;
				s1 = new BitArray(this.terminals.length, false);
				while (q != null) { // for all alternatives
					s2 = this.Expected0(q.sub, this.curSy);
					this.CheckOverlap(s1, s2, 1);
					s1.Or(s2);
					this.CheckAlts(q.sub);
					q = q.down;
				}
			} else if (p.typ == Node.opt || p.typ == Node.iter) {
				if (Tab.DelSubGraph(p.sub)) {
					this.LL1Error(4, null); // e.g. [[...]]
				} else {
					s1 = this.Expected0(p.sub, this.curSy);
					s2 = this.Expected(p.next, this.curSy);
					this.CheckOverlap(s1, s2, 2);
				}

				this.CheckAlts(p.sub);
			} else if (p.typ == Node.any) {
				if (Sets.Elements(p.set ) == 0) {
					this.LL1Error(3, null);
					// e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
				}
			}
			if (p.up) {
				break;
			}
			p = p.next;
		}
	}

	public CheckLL1() {
		var outer = this;
		this.nonterminals.forEach(function (sym) {
			outer.curSy = sym;
			outer.CheckAlts(outer.curSy.graph);
		});
	}

//------------- check if resolvers are legal  --------------------

	ResErr(p: Node, msg: string) {
		this.errors.WarningPositioned(p.line, p.pos.col, msg);
	}

	CheckRes(p: Node, rslvAllowed: bool) {
		while (p != null) {
			switch (p.typ) {
				case Node.alt:
					var expected = new BitArray(this.terminals.length, false);
					for (var q = p; q != null; q = q.down) {
						expected.Or(this.Expected0(q.sub, this.curSy));
					}

					var soFar = new BitArray(this.terminals.length, false);
					for (var q = p; q != null; q = q.down) {
						if (q.sub.typ == Node.rslv) {
							var fs = this.Expected(q.sub.next, this.curSy);
							if (Sets.Intersect(fs, soFar)) {
								this.ResErr(q.sub, "Warning: Resolver will never be evaluated. " +
								"Place it at previous conflicting alternative.");
							}

							if (!Sets.Intersect(fs, expected)) {
								this.ResErr(q.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
							}
						} else {
							soFar.Or(this.Expected(q.sub, this.curSy));
						}

						this.CheckRes(q.sub, true);
					}
					break;
				case Node.iter:
				case Node.opt:
					if (p.sub.typ == Node.rslv) {
						var fs = this.First(p.sub.next);
						var fsNext = this.Expected(p.next, this.curSy);
						if (!Sets.Intersect(fs, fsNext)) {
							this.ResErr(p.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
						}
					}

					this.CheckRes(p.sub, true);
					break;
				case Node.rslv:
					if (!rslvAllowed) {
						this.ResErr(p, "Warning: Misplaced resolver: no alternative.");
					}
					break;
			}	

			if (p.up) {
				break;
			}

			p = p.next;
			rslvAllowed = false;
		}
	}

	public CheckResolvers() {
		var outer = this;
		this.nonterminals.forEach(function (sym) {
			outer.curSy = sym;
			outer.CheckRes(this.curSy.graph, false);
		});
	}

//------------- check if every nts has a production --------------------

	public NtsComplete() : bool {
		var complete = true;
		var outer = this;
		this.nonterminals.forEach(function (sym) {
			if (sym.graph == null) {
				complete = false;
				outer.errors.SemErr("  No production for " + sym.name);
			}
		
		});

		return complete;
	}

//-------------- check if every nts can be reached  -----------------

	MarkReachedNts(p: Node) {
		while (p != null) {
			if (p.typ == Node.nt && !this.visited[p.sym.n]) { // new nt reached
				this.visited[p.sym.n]= true;
				this.MarkReachedNts(p.sym.graph);
			} else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt) {
				this.MarkReachedNts(p.sub);
				if (p.typ == Node.alt) {
					this.MarkReachedNts(p.down);
				}
			}

			if (p.up) {
				break;
			}
			p = p.next;
		}
	}

	public AllNtReached(): bool {
		var ok = true;
		this.visited = new BitArray(this.nonterminals.length, false);
		this.visited[this.gramSy.n]= true;
		this.MarkReachedNts(this.gramSy.graph);
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			if (!this.visited[sym.n]) {
				ok = false;
				this.errors.Warning("  " +sym.name + " cannot be reached");
			}
		}
		return ok;
	}

//--------- check if every nts can be derived to terminals  ------------

	IsTerm(p: Node, mark: BitArray): bool { // true if graph can be derived to terminals
		while (p != null) {
			if (p.typ == Node.nt && !mark[p.sym.n]) {
				return false;
			}

			if (p.typ == Node.alt && !this.IsTerm(p.sub, mark)
				&& (p.down == null || !this.IsTerm(p.down, mark))) {
				return false;
			}

			if (p.up) {
				break;
			}

			p = p.next;
		}
		return true;
	}

	public AllNtToTerm(): bool {
		var changed: bool;
		var ok = true;
		var mark = new BitArray(this.nonterminals.length, false);
// a nonterminal is marked if it can be derived to terminal symbols
		do {
			changed = false;
			for(var i = 0; i < this.nonterminals.length; i++) {
				var sym = this.nonterminals[i];
				if (!mark[sym.n] && this.IsTerm(sym.graph, mark)) {
					mark[sym.n] = true; changed = true;
				}
			}
		} while (changed);

		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			if (!mark[sym.n]) {
				ok = false;
				this.errors.SemErr("  " + sym.name + " cannot be derived to terminals");
			}
		}

		return ok;
	}

	//---------------------------------------------------------------------
	//  Cross reference list
	//---------------------------------------------------------------------

	public XRef() {
		var xref = {};
		// collect lines where symbols have been defined
		for(var i = 0; i < this.nonterminals.length; i++) {
			var sym = this.nonterminals[i];
			var list = xref[sym.name];
			if (list == null) {
				list = [];
				xref[sym.name] = list;
			}
			list.Add(-sym.line);
		}
		// collect lines where symbols have been referenced
		for(var i = 0; i < this.nodes.length; i++) {
			var n = this.nodes[i];
			if (n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt) {
				var list = xref[n.sym.name];
				if (list == null) {
					list = [];
					xref[n.sym.name] = list;
				}

				list.Add(n.line);
			}
		}

		// print cross reference list
		this.trace.WriteLine();
		this.trace.WriteLineText("Cross reference list:");
		this.trace.WriteLineText("--------------------");
		for(var sym in xref) {
			this.trace.WriteFormatted1("  {0,-12}", this.Name(sym.name));
			var list = xref[sym.name];
			var col: number = 14;
			for(var j = 0; j < list.length; j++) {
				var line = list[j];
				if (col +5 > 80) {
					this.trace.WriteLine();
					for (col = 1; col <= 14; col++) {
						this.trace.Write(" ");
					}
				}
				this.trace.WriteFormatted1("{0,5}", line);
				col += 5;
			}
			this.trace.WriteLine();
		}
		this.trace.WriteLine();
		this.trace.WriteLine();
	}

	public SetDDT(s: string) {
		s = s.toUpperCase();
		for(var i = 0; i < s.length; i++) {
			var ch = s.charCodeAt(i);
			if ('0'.charCodeAt(0) <= ch && ch <= '9'.charCodeAt(0)) {
				this.ddt[ch - '0'.charCodeAt(0)] = true;
			} else {
				switch (ch) {
					case 'A': this.ddt[0] = true; break; // trace automaton
					case 'F': this.ddt[1] = true; break; // list first/follow sets
					case 'G': this.ddt[2] = true; break; // print syntax graph
					case 'I': this.ddt[3] = true; break; // trace computation of first sets
					case 'J': this.ddt[4] = true; break; // print ANY and SYNC sets
					case 'P': this.ddt[8] = true; break; // print statistics
					case 'S': this.ddt[6] = true; break; // list symbol table
					case 'X': this.ddt[7] = true; break; // list cross reference table
					default: break;
				}
			}
		}
	}

	public SetOption(s: string) {
		var option: string[] = s.split("=", 2);
		var name :string = option[0];
		var value : string = option[1];
		if ("$namespace" == name) {
			if (this.nsName == null) {
				this.nsName = value;
			}
		} else if ("$checkEOF" == name) {
			this.checkEOF = "true" == value;
		}
	}
} // end Tab

} // end namespace
