var at;
(function (at) {
    (function (jku) {
        (function (ssw) {
            /*-------------------------------------------------------------------------
            Tab.cs -- Symbol Table Management
            Compiler Generator Coco/R,
            Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
            extended by M. Loeberbauer & A. Woess, Univ. of Linz
            with improvements by Pat Terry, Rhodes University
            
            This program is free software; you can redistribute it and/or modify it
            under the terms of the GNU General Public License as published by the
            Free Software Foundation; either version 2, or (at your option) any
            later version.
            
            This program is distributed in the hope that it will be useful, but
            WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
            or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
            for more details.
            
            You should have received a copy of the GNU General Public License along
            with this program; if not, write to the Free Software Foundation, Inc.,
            59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
            
            As an exception, it is allowed to write an extension of Coco/R that is
            used as a plugin in non-free software.
            
            If not otherwise stated, any source code generated by Coco/R (other than
            Coco/R itself) does not fall under the GNU General Public License.
            -------------------------------------------------------------------------*/
            /// <reference path="DFA.ts" />
            /// <reference path="Parser.ts" />
            (function (coco) {
                var Position = (function () {
                    function Position(beg, end, col, line) {
                        this._beg = beg;
                        this._end = end;
                        this._col = col;
                        this._line = line;
                    }
                    Object.defineProperty(Position.prototype, "beg", {
                        get: function () {
                            return this._beg;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Position.prototype, "end", {
                        get: function () {
                            return this._end;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Position.prototype, "col", {
                        get: function () {
                            return this._col;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Position.prototype, "line", {
                        get: function () {
                            return this._line;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return Position;
                })();
                coco.Position = Position;

                //=====================================================================
                // Symbol
                //=====================================================================
                var Symbol = (function () {
                    // nt: pos of local declarations in source text (or null)
                    function Symbol(typ, name, line) {
                        this.typ = typ;
                        this.name = name;
                        this.line = line;
                    }
                    Object.defineProperty(Symbol, "fixedToken", {
                        get: // token kinds
                        function () {
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symbol, "classToken", {
                        get: function () {
                            return 1;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symbol, "litToken", {
                        get: function () {
                            return 2;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symbol, "classLitToken", {
                        get: function () {
                            return 3;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return Symbol;
                })();
                coco.Symbol = Symbol;

                //=====================================================================
                // Node
                //=====================================================================
                var Node = (function () {
                    // (only used in DFA.ConvertToStates)
                    function Node(typ, sym, line) {
                        this.typ = typ;
                        this.sym = sym;
                        this.line = line;
                    }
                    Object.defineProperty(Node, "t", {
                        get: // constants for node kinds
                        function () {
                            return 1;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "pr", {
                        get: function () {
                            return 2;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "nt", {
                        get: function () {
                            return 3;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "clas", {
                        get: function () {
                            return 4;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "chr", {
                        get: function () {
                            return 5;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "wt", {
                        get: function () {
                            return 6;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "any", {
                        get: function () {
                            return 7;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "eps", {
                        get: function () {
                            return 8;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "sync", {
                        get: function () {
                            return 9;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "sem", {
                        get: function () {
                            return 10;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "alt", {
                        get: function () {
                            return 11;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "iter", {
                        get: function () {
                            return 12;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "opt", {
                        get: function () {
                            return 13;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "rslv", {
                        get: function () {
                            return 14;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Node, "normalTrans", {
                        get: function () {
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Node, "contextTrans", {
                        get: function () {
                            return 1;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return Node;
                })();
                coco.Node = Node;

                //=====================================================================
                // Graph
                //=====================================================================
                var Graph = (function () {
                    function Graph(left, right) {
                        this.l = left;
                        this.r = right;
                    }
                    return Graph;
                })();
                coco.Graph = Graph;

                var CNode = (function () {
                    function CNode(l, r) {
                        this.left = l;
                        this.right = r;
                    }
                    return CNode;
                })();

                //=====================================================================
                // Sets
                //=====================================================================
                var Sets = (function () {
                    function Sets() {
                    }
                    Sets.Elements = function (s) {
                        var max = s.Count;
                        var n = 0;
                        for (var i = 0; i < max; i++)
                            if (s[i])
                                n++;
                        return n;
                    };

                    Sets.Equals = function (a, b) {
                        var max = a.Count;
                        for (var i = 0; i < max; i++)
                            if (a[i] != b[i])
                                return false;
                        return true;
                    };

                    Sets.Intersect = function (a, b) {
                        var max = a.Count;
                        for (var i = 0; i < max; i++)
                            if (a[i] && b[i])
                                return true;
                        return false;
                    };

                    Sets.Subtract = function (a, b) {
                        var c = b.Clone();
                        a.And(c.Not());
                    };
                    return Sets;
                })();
                coco.Sets = Sets;

                //=====================================================================
                // CharClass
                //=====================================================================
                var CharClass = (function () {
                    function CharClass(name, s) {
                        this.name = name;
                        this.set = s;
                    }
                    return CharClass;
                })();
                coco.CharClass = CharClass;

                //=====================================================================
                // Tab
                //=====================================================================
                var Tab = (function () {
                    function Tab(parser) {
                        this.ddt = new Array(10);
                        this.checkEOF = true;
                        //---------------------------------------------------------------------
                        //  Symbol list management
                        //---------------------------------------------------------------------
                        this.terminals = [];
                        this.pragmas = [];
                        this.nonterminals = [];
                        this.tKind = ["fixedToken", "classToken", "litToken", "classLitToken"];
                        //---------------------------------------------------------------------
                        //  Syntax graph management
                        //---------------------------------------------------------------------
                        this.nodes = [];
                        this.nTyp = [
                            "    ",
                            "t   ",
                            "pr  ",
                            "nt  ",
                            "clas",
                            "chr ",
                            "wt  ",
                            "any ",
                            "eps ",
                            "sync",
                            "sem ",
                            "alt ",
                            "iter",
                            "opt ",
                            "rslv"
                        ];
                        //---------------------------------------------------------------------
                        //  Character class management
                        //---------------------------------------------------------------------
                        this.classes = [];
                        this.dummyName = 'A'.charCodeAt(0);
                        this.parser = parser;
                        this.trace = this.parser.trace;
                        this.errors = this.parser.errors;
                        this.eofSy = this.NewSym(Node.t, "EOF", 0);
                        this.dummyNode = this.NewNode(Node.eps, null, 0);
                        this.literals = new coco.Hashtable();
                    }
                    Tab.prototype.NewSym = function (typ, name, line) {
                        if (name.length == 2 && name[0] == '"') {
                            this.parser.SemErr("empty token not allowed");
                            name = "???";
                        }

                        var sym = new Symbol(typ, name, line);
                        switch (typ) {
                            case Node.t:
                                sym.n = this.terminals.length;
                                this.terminals.push(sym);
                                break;
                            case Node.pr:
                                this.pragmas.push(sym);
                                break;
                            case Node.nt:
                                sym.n = this.nonterminals.length;
                                this.nonterminals.push(sym);
                                break;
                        }
                        return sym;
                    };

                    Tab.prototype.FindSym = function (name) {
                        for (var i = 0; i < this.terminals.length; i++) {
                            var s = this.terminals[i];
                            if (s.name == name)
                                return s;
                        }
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var s = this.nonterminals[i];
                            if (s.name == name)
                                return s;
                        }

                        return null;
                    };

                    Tab.prototype.Num = function (p) {
                        if (p == null)
                            return 0; else
                            return p.n;
                    };

                    Tab.prototype.PrintSym = function (sym) {
                        this.trace.WriteFormatted3("{0,3} {1,-14} {2}", sym.n, this.Name(sym.name), this.nTyp[sym.typ]);
                        if (sym.attrPos == null) {
                            this.trace.Write(" false ");
                        } else {
                            this.trace.Write(" true  ");
                        }

                        if (sym.typ == Node.nt) {
                            this.trace.WriteFormatted1("{0,5}", this.Num(sym.graph));
                            if (sym.deletable) {
                                this.trace.Write(" true  ");
                            } else {
                                this.trace.Write(" false ");
                            }
                        } else {
                            this.trace.Write("            ");
                        }

                        this.trace.WriteLineFormatted2("{0,5} {1}", sym.line, this.tKind[sym.tokenKind]);
                    };

                    Tab.prototype.PrintSymbolTable = function () {
                        this.trace.WriteLineText("Symbol Table:");
                        this.trace.WriteLineText("------------");
                        this.trace.WriteLine();
                        this.trace.WriteLineText(" nr name          typ  hasAt graph  del    line tokenKind");
                        for (var i = 0; i < this.terminals.length; i++) {
                            this.PrintSym(this.terminals[i]);
                        }
                        for (var i = 0; i < this.pragmas.length; i++) {
                            this.PrintSym(this.pragmas[i]);
                        }
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            this.PrintSym(this.nonterminals[i]);
                        }
                        this.trace.WriteLine();
                        this.trace.WriteLineText("Literal Tokens:");
                        this.trace.WriteLineText("--------------");
                        for (var i = 0; i < this.literals.length; i++) {
                            var e = this.literals[i];
                            this.trace.WriteLineText("_" + e.Value.name + " = " + e.Key + ".");
                        }
                        this.trace.WriteLine();
                    };

                    Tab.prototype.PrintSet = function (s, indent) {
                        var col;
                        var len;
                        col = indent;
                        for (var i = 0; i < this.terminals.length; i++) {
                            var sym = this.terminals[i];
                            if (s[sym.n]) {
                                len = sym.name.length;
                                if (col + len >= 80) {
                                    this.trace.WriteLine();
                                    for (col = 1; col < indent; col++)
                                        this.trace.Write(" ");
                                }

                                this.trace.WriteFormatted1("{0} ", sym.name);
                                col += len + 1;
                            }
                        }

                        if (col == indent) {
                            this.trace.Write("-- empty set --");
                        }
                        this.trace.WriteLine();
                    };

                    Tab.prototype.NewNode = function (typ, sym, line) {
                        var node = new Node(typ, sym, line);
                        node.n = this.nodes.length;
                        this.nodes.push(node);
                        return node;
                    };

                    Tab.prototype.NewNodeTypeSubNode = function (typ, sub) {
                        var node = this.NewNode(typ, null, 0);
                        node.sub = sub;
                        return node;
                    };

                    /*
                    public NewNode(typ : number, val : number, line : number): Node {
                    var node = NewNode(typ, null, line);
                    node.val = val;
                    return node;
                    }
                    */
                    Tab.prototype.MakeFirstAlt = function (g) {
                        g.l = this.NewNodeTypeSubNode(Node.alt, g.l);
                        g.l.line = g.l.sub.line;
                        g.r.up = true;
                        g.l.next = g.r;
                        g.r = g.l;
                    };

                    // The result will be in g1
                    Tab.prototype.MakeAlternative = function (g1, g2) {
                        g2.l = this.NewNodeTypeSubNode(Node.alt, g2.l);
                        g2.l.line = g2.l.sub.line;
                        g2.l.up = true;
                        g2.r.up = true;
                        var p = g1.l;
                        while (p.down != null)
                            p = p.down;
                        p.down = g2.l;
                        p = g1.r;
                        while (p.next != null)
                            p = p.next;

                        // append alternative to g1 end list
                        p.next = g2.l;

                        // append g2 end list to g1 end list
                        g2.l.next = g2.r;
                    };

                    // The result will be in g1
                    Tab.prototype.MakeSequence = function (g1, g2) {
                        var p = g1.r.next;
                        g1.r.next = g2.l;
                        while (p != null) {
                            var q = p.next;
                            p.next = g2.l;
                            p = q;
                        }
                        g1.r = g2.r;
                    };

                    Tab.prototype.MakeIteration = function (g) {
                        g.l = this.NewNodeTypeSubNode(Node.iter, g.l);
                        g.r.up = true;
                        var p = g.r;
                        g.r = g.l;
                        while (p != null) {
                            var q = p.next;
                            p.next = g.l;
                            p = q;
                        }
                    };

                    Tab.prototype.MakeOption = function (g) {
                        g.l = this.NewNodeTypeSubNode(Node.opt, g.l);
                        g.r.up = true;
                        g.l.next = g.r;
                        g.r = g.l;
                    };

                    Tab.prototype.Finish = function (g) {
                        var p = g.r;
                        while (p != null) {
                            var q = p.next;
                            p.next = null;
                            p = q;
                        }
                    };

                    Tab.prototype.DeleteNodes = function () {
                        this.nodes = [];
                        this.dummyNode = this.NewNode(Node.eps, null, 0);
                    };

                    Tab.prototype.StrToGraph = function (str) {
                        var s = this.Unescape(str.substring(1, str.length - 2));
                        if (s.length == 0)
                            this.parser.SemErr("empty token not allowed");
                        var g = new Graph(null, null);
                        g.r = this.dummyNode;
                        for (var i = 0; i < s.length; i++) {
                            var p = this.NewNode(Node.chr, s[i], 0);
                            g.r.next = p;
                            g.r = p;
                        }

                        g.l = this.dummyNode.next;
                        this.dummyNode.next = null;
                        return g;
                    };

                    Tab.prototype.SetContextTrans = function (p) {
                        while (p != null) {
                            if (p.typ == Node.chr || p.typ == Node.clas) {
                                p.code = Node.contextTrans;
                            } else if (p.typ == Node.opt || p.typ == Node.iter) {
                                this.SetContextTrans(p.sub);
                            } else if (p.typ == Node.alt) {
                                this.SetContextTrans(p.sub);
                                this.SetContextTrans(p.down);
                            }

                            if (p.up)
                                break;
                            p = p.next;
                        }
                    };

                    Tab.DelGraph = //------------ graph deletability check -----------------
                    function (p) {
                        return p == null || Tab.DelNode(p) && Tab.DelGraph(p.next);
                    };

                    Tab.DelSubGraph = function (p) {
                        return p == null || Tab.DelNode(p) && (p.up || Tab.DelSubGraph(p.next));
                    };

                    Tab.DelNode = function (p) {
                        if (p.typ == Node.nt) {
                            return p.sym.deletable;
                        } else if (p.typ == Node.alt) {
                            return Tab.DelSubGraph(p.sub) || p.down != null && Tab.DelSubGraph(p.down);
                        } else {
                            return p.typ == Node.iter || p.typ == Node.opt || p.typ == Node.sem || p.typ == Node.eps || p.typ == Node.rslv || p.typ == Node.sync;
                        }
                    };

                    //----------------- graph printing ----------------------
                    Tab.prototype.Ptr = function (p, up) {
                        var ptr = (p == null) ? "0" : p.n.toString();
                        return (up) ? ("-" + ptr) : ptr;
                    };

                    Tab.Format = function (formatString, o1) {
                        // TODO
                        return null;
                    };

                    Tab.prototype.Pos = function (pos) {
                        if (pos == null) {
                            return "     ";
                        } else {
                            return Tab.Format("{0,5}", pos.beg);
                        }
                    };

                    Tab.prototype.Name = function (name) {
                        return (name + "           ").substring(0, 12);
                    };

                    Tab.prototype.PrintNodes = function () {
                        this.trace.WriteLineText("Graph nodes:");
                        this.trace.WriteLineText("----------------------------------------------------");
                        this.trace.WriteLineText("   n type name          next  down   sub   pos  line");
                        this.trace.WriteLineText("                               val  code");
                        this.trace.WriteLineText("----------------------------------------------------");
                        for (var i = 0; i < this.nodes.length; i++) {
                            var p = this.nodes[i];
                            this.trace.WriteFormatted2("{0,4} {1} ", p.n, this.nTyp[p.typ]);
                            if (p.sym != null) {
                                this.trace.WriteFormatted1("{0,12} ", this.Name(p.sym.name));
                            } else if (p.typ == Node.clas) {
                                var c = this.classes[p.val];
                                this.trace.WriteFormatted1("{0,12} ", this.Name(c.name));
                            } else {
                                this.trace.Write("             ");
                            }

                            this.trace.WriteFormatted1("{0,5} ", this.Ptr(p.next, p.up));
                            switch (p.typ) {
                                case Node.t:
                                case Node.nt:
                                case Node.wt:
                                    this.trace.WriteFormatted1("             {0,5}", this.Pos(p.pos));
                                    break;
                                case Node.chr:
                                    this.trace.WriteFormatted2("{0,5} {1,5}       ", p.val, p.code);
                                    break;
                                case Node.clas:
                                    this.trace.WriteFormatted1("      {0,5}       ", p.code);
                                    break;
                                case Node.alt:
                                case Node.iter:
                                case Node.opt:
                                    this.trace.WriteFormatted2("{0,5} {1,5}       ", this.Ptr(p.down, false), this.Ptr(p.sub, false));
                                    break;
                                case Node.sem:
                                    this.trace.WriteFormatted1("             {0,5}", this.Pos(p.pos));
                                    break;
                                case Node.eps:
                                case Node.any:
                                case Node.sync:
                                    this.trace.Write("                  ");
                                    break;
                            }

                            this.trace.WriteLineFormatted1("{0,5}", p.line);
                        }
                        this.trace.WriteLine();
                    };

                    Tab.prototype.NewCharClass = function (name, s) {
                        if (name == "#") {
                            name = "#" + String.fromCharCode(this.dummyName++);
                        }

                        var c = new CharClass(name, s);
                        c.n = this.classes.length;
                        this.classes.push(c);
                        return c;
                    };

                    Tab.prototype.FindCharClass = function (name) {
                        for (var i = 0; i < this.classes.length; i++) {
                            var c = this.classes[i];
                            if (c.name == name)
                                return c;
                        }

                        return null;
                    };

                    Tab.prototype.FindCharClassCS = function (s) {
                        for (var i = 0; i < this.classes.length; i++) {
                            var c = this.classes[i];
                            if (s.Equals(c.set))
                                return c;
                        }
                        return null;
                    };

                    Tab.prototype.CharClassSet = function (i) {
                        return this.classes[i].set;
                    };

                    Tab.Ch = //----------- character class printing
                    function (ch) {
                        if (ch < ' '.charCodeAt(0) || ch >= 127 || ch == '\''.charCodeAt(0) || ch == '\\'.charCodeAt(0))
                            return String.fromCharCode(ch); else
                            return "'\\u" + ch.toString(16) + "'";
                    };

                    Tab.prototype.WriteCharSet = function (s) {
                        for (var r = s.head; r != null; r = r.next) {
                            if (r.from < r.to) {
                                this.trace.Write(Tab.Ch(r.from) + ".." + Tab.Ch(r.to) + " ");
                            } else {
                                this.trace.Write(Tab.Ch(r.from) + " ");
                            }
                        }
                    };

                    Tab.prototype.WriteCharClasses = function () {
                        for (var i = 0; i < this.classes.length; i++) {
                            var c = this.classes[i];
                            this.trace.WriteFormatted1("{0,-10}: ", c.name);
                            this.WriteCharSet(c.set);
                            this.trace.WriteLine();
                        }

                        this.trace.WriteLine();
                    };

                    //---------------------------------------------------------------------
                    //  Symbol set computations
                    //---------------------------------------------------------------------
                    /* Computes the first set for the graph rooted at p */
                    Tab.prototype.First0 = function (p, mark) {
                        var fs = new coco.BitArray(this.terminals.length, false);
                        while (p != null && !mark[p.n]) {
                            mark[p.n] = true;
                            switch (p.typ) {
                                case Node.nt: {
                                    if (p.sym.firstReady) {
                                        fs.Or(p.sym.first);
                                    } else {
                                        fs.Or(this.First0(p.sym.graph, mark));
                                    }
                                    break;
                                }
                                case Node.t:
                                case Node.wt: {
                                    fs[p.sym.n] = true;
                                    break;
                                }
                                case Node.any: {
                                    fs.Or(p.set);
                                    break;
                                }
                                case Node.alt: {
                                    fs.Or(this.First0(p.sub, mark));
                                    fs.Or(this.First0(p.down, mark));
                                    break;
                                }
                                case Node.iter:
                                case Node.opt: {
                                    fs.Or(this.First0(p.sub, mark));
                                    break;
                                }
                            }
                            if (!Tab.DelNode(p))
                                break;
                            p = p.next;
                        }
                        return fs;
                    };

                    Tab.prototype.First = function (p) {
                        var fs = this.First0(p, new coco.BitArray(this.nodes.length, false));
                        if (this.ddt[3]) {
                            this.trace.WriteLine();
                            if (p != null) {
                                this.trace.WriteLineFormatted1("First: node = {0}", p.n);
                            } else {
                                this.trace.WriteLineText("First: node = null");
                            }

                            this.PrintSet(fs, 0);
                        }
                        return fs;
                    };

                    Tab.prototype.CompFirstSets = function () {
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            sym.first = new coco.BitArray(this.terminals.length, false);
                            sym.firstReady = false;
                        }
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            sym.first = this.First(sym.graph);
                            sym.firstReady = true;
                        }
                    };

                    Tab.prototype.CompFollow = function (p) {
                        while (p != null && !this.visited[p.n]) {
                            this.visited[p.n] = true;
                            if (p.typ == Node.nt) {
                                var s = this.First(p.next);
                                p.sym.follow.Or(s);
                                if (Tab.DelGraph(p.next)) {
                                    p.sym.nts[this.curSy.n] = true;
                                }
                            } else if (p.typ == Node.opt || p.typ == Node.iter) {
                                this.CompFollow(p.sub);
                            } else if (p.typ == Node.alt) {
                                this.CompFollow(p.sub);
                                this.CompFollow(p.down);
                            }
                            p = p.next;
                        }
                    };

                    Tab.prototype.Complete = function (sym) {
                        if (!this.visited[sym.n]) {
                            this.visited[sym.n] = true;
                            for (var i = 0; i < this.nonterminals.length; i++) {
                                var s = this.nonterminals[i];
                                if (sym.nts[s.n]) {
                                    this.Complete(s);
                                    sym.follow.Or(s.follow);
                                    if (sym == this.curSy) {
                                        sym.nts[s.n] = false;
                                    }
                                }
                            }
                        }
                    };

                    Tab.prototype.CompFollowSets = function () {
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            sym.follow = new coco.BitArray(this.terminals.length, false);
                            sym.nts = new coco.BitArray(this.nonterminals.length, false);
                        }

                        this.gramSy.follow[this.eofSy.n] = true;
                        this.visited = new coco.BitArray(this.nodes.length, false);
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            this.curSy = sym;
                            this.CompFollow(sym.graph);
                        }

                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            this.visited = new coco.BitArray(this.nonterminals.length, false);
                            this.curSy = sym;
                            this.Complete(sym);
                        }
                    };

                    Tab.prototype.LeadingAny = function (p) {
                        if (p == null) {
                            return null;
                        }

                        var a = null;
                        if (p.typ == Node.any) {
                            a = p;
                        } else if (p.typ == Node.alt) {
                            a = this.LeadingAny(p.sub);
                            if (a == null) {
                                a = this.LeadingAny(p.down);
                            }
                        } else if (p.typ == Node.opt || p.typ == Node.iter) {
                            a = this.LeadingAny(p.sub);
                        }

                        if (a == null && Tab.DelNode(p) && !p.up) {
                            a = this.LeadingAny(p.next);
                        }

                        return a;
                    };

                    Tab.prototype.FindAS = function (p) {
                        var a;
                        while (p != null) {
                            if (p.typ == Node.opt || p.typ == Node.iter) {
                                this.FindAS(p.sub);
                                a = this.LeadingAny(p.sub);
                                if (a != null) {
                                    Sets.Subtract(a.set, this.First(p.next));
                                }
                            } else if (p.typ == Node.alt) {
                                var s1 = new coco.BitArray(this.terminals.length, false);
                                var q = p;
                                while (q != null) {
                                    this.FindAS(q.sub);
                                    a = this.LeadingAny(q.sub);
                                    if (a != null) {
                                        Sets.Subtract(a.set, this.First(q.down).Or(s1));
                                    } else {
                                        s1.Or(this.First(q.sub));
                                    }
                                    q = q.down;
                                }
                            }

                            if (Tab.DelNode(p)) {
                                a = this.LeadingAny(p.next);
                                if (a != null) {
                                    var q = (p.typ == Node.nt) ? p.sym.graph : p.sub;
                                    Sets.Subtract(a.set, this.First(q));
                                }
                            }

                            if (p.up) {
                                break;
                            }

                            p = p.next;
                        }
                    };

                    Tab.prototype.CompAnySets = function () {
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            this.FindAS(sym.graph);
                        }
                    };

                    Tab.prototype.Expected = function (p, curSy) {
                        var s = this.First(p);
                        if (Tab.DelGraph(p)) {
                            s.Or(curSy.follow);
                        }
                        return s;
                    };

                    // does not look behind resolvers; only called during LL(1) test and in CheckRes
                    Tab.prototype.Expected0 = function (p, curSy) {
                        if (p.typ == Node.rslv) {
                            return new coco.BitArray(this.terminals.length, false);
                        } else {
                            return this.Expected(p, curSy);
                        }
                    };

                    Tab.prototype.CompSync = function (p) {
                        while (p != null && !this.visited[p.n]) {
                            this.visited[p.n] = true;
                            if (p.typ == Node.sync) {
                                var s = this.Expected(p.next, this.curSy);
                                s[this.eofSy.n] = true;
                                this.allSyncSets.Or(s);
                                p.set = s;
                            } else if (p.typ == Node.alt) {
                                this.CompSync(p.sub);
                                this.CompSync(p.down);
                            } else if (p.typ == Node.opt || p.typ == Node.iter) {
                                this.CompSync(p.sub);
                            }
                            p = p.next;
                        }
                    };

                    Tab.prototype.CompSyncSets = function () {
                        this.allSyncSets = new coco.BitArray(this.terminals.length, false);
                        this.allSyncSets[this.eofSy.n] = true;
                        this.visited = new coco.BitArray(this.nodes.length, false);
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            this.curSy = sym;
                            this.CompSync(this.curSy.graph);
                        }
                    };

                    Tab.prototype.SetupAnys = function () {
                        for (var i = 0; i < this.nodes.length; i++) {
                            var p = this.nodes[i];
                            if (p.typ == Node.any) {
                                p.set = new coco.BitArray(this.terminals.length, true);
                                p.set[this.eofSy.n] = false;
                            }
                        }
                    };

                    Tab.prototype.CompDeletableSymbols = function () {
                        var changed;
                        do {
                            changed = false;
                            for (var i = 0; i < this.nonterminals.length; i++) {
                                var sym = this.nonterminals[i];
                                if (!sym.deletable && sym.graph != null && Tab.DelGraph(sym.graph)) {
                                    sym.deletable = true;
                                    changed = true;
                                }
                            }
                        } while(changed);

                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            if (sym.deletable) {
                                this.errors.Warning("  " + sym.name + " deletable");
                            }
                        }
                    };

                    Tab.prototype.RenumberPragmas = function () {
                        var n = this.terminals.length;
                        for (var i = 0; i < this.pragmas.length; i++) {
                            var sym = this.pragmas[i];
                            sym.n = n++;
                        }
                    };

                    Tab.prototype.CompSymbolSets = function () {
                        this.CompDeletableSymbols();
                        this.CompFirstSets();
                        this.CompAnySets();
                        this.CompFollowSets();
                        this.CompSyncSets();
                        if (this.ddt[1]) {
                            this.trace.WriteLine();
                            this.trace.WriteLineText("First & follow symbols:");
                            this.trace.WriteLineText("----------------------");
                            this.trace.WriteLine();
                            for (var i = 0; i < this.nonterminals.length; i++) {
                                var sym = this.nonterminals[i];
                                this.trace.WriteLineText(sym.name);
                                this.trace.Write("first:   ");
                                this.PrintSet(sym.first, 10);
                                this.trace.Write("follow:  ");
                                this.PrintSet(sym.follow, 10);
                                this.trace.WriteLine();
                            }
                        }
                        if (this.ddt[4]) {
                            this.trace.WriteLine();
                            this.trace.WriteLineText("ANY and SYNC sets:");
                            this.trace.WriteLineText("-----------------");
                            for (var i = 0; i < this.nodes.length; i++) {
                                var p = this.nodes[i];
                                if (p.typ == Node.any || p.typ == Node.sync) {
                                    this.trace.WriteFormatted2("{0,4} {1,4}: ", p.n, this.nTyp[p.typ]);
                                    this.PrintSet(p.set, 11);
                                }
                            }
                        }
                    };

                    //---------------------------------------------------------------------
                    //  String handling
                    //---------------------------------------------------------------------
                    Tab.prototype.Hex2Char = function (s) {
                        return String.fromCharCode(parseInt(s, 16));
                    };

                    Tab.prototype.Char2Hex = function (ch) {
                        //w.WriteFormatted1("\\u{0:x4}", ch);
                        return "\\u" + ch.toString(16);
                    };

                    Tab.prototype.Unescape = function (s) {
                        /* replaces escape sequences in s by their Unicode values. */
                        var buf = new coco.StringBuilder("");
                        var i = 0;
                        while (i < s.length) {
                            if (s[i] == '\\') {
                                switch (s[i + 1]) {
                                    case '\\':
                                        buf.append('\\');
                                        i += 2;
                                        break;
                                    case '\'':
                                        buf.append('\'');
                                        i += 2;
                                        break;
                                    case '\"':
                                        buf.append('\"');
                                        i += 2;
                                        break;
                                    case 'r':
                                        buf.append('\r');
                                        i += 2;
                                        break;
                                    case 'n':
                                        buf.append('\n');
                                        i += 2;
                                        break;
                                    case 't':
                                        buf.append('\t');
                                        i += 2;
                                        break;
                                    case '0':
                                        buf.append('\0');
                                        i += 2;
                                        break;
                                    case 'a':
                                        buf.append('\a');
                                        i += 2;
                                        break;
                                    case 'b':
                                        buf.append('\b');
                                        i += 2;
                                        break;
                                    case 'f':
                                        buf.append('\f');
                                        i += 2;
                                        break;
                                    case 'v':
                                        buf.append('\v');
                                        i += 2;
                                        break;
                                    case 'u':
                                    case 'x':
                                        if (i + 6 <= s.length) {
                                            buf.append(this.Hex2Char(s.substring(i + 2, 4)));
                                            i += 6;
                                            break;
                                        } else {
                                            this.parser.SemErr("bad escape sequence in string or character");
                                            i = s.length;
                                            break;
                                        }
                                    default:
                                        this.parser.SemErr("bad escape sequence in string or character");
                                        i += 2;
                                        break;
                                }
                            } else {
                                buf.append(s[i]);
                                i++;
                            }
                        }

                        return buf.toString();
                    };

                    Tab.prototype.Escape = function (s) {
                        var buf = new coco.StringBuilder("");
                        for (var i = 0; i < s.length; i++) {
                            var ch = s.charCodeAt(i);
                            switch (ch) {
                                case '\\'.charCodeAt(0):
                                    buf.append("\\\\");
                                    break;
                                case '\''.charCodeAt(0):
                                    buf.append("\\'");
                                    break;
                                case '\"'.charCodeAt(0):
                                    buf.append("\\\"");
                                    break;
                                case '\t'.charCodeAt(0):
                                    buf.append("\\t");
                                    break;
                                case '\r'.charCodeAt(0):
                                    buf.append("\\r");
                                    break;
                                case '\n'.charCodeAt(0):
                                    buf.append("\\n");
                                    break;
                                default:
                                    if (ch < ' '.charCodeAt(0) || ch > '\u007f'.charCodeAt(0)) {
                                        buf.append(this.Char2Hex(ch));
                                    } else {
                                        buf.append(String.fromCharCode(ch));
                                    }
                                    break;
                            }
                        }

                        return buf.toString();
                    };

                    //---------------------------------------------------------------------
                    //  Grammar checks
                    //---------------------------------------------------------------------
                    Tab.prototype.GrammarOk = function () {
                        var ok = this.NtsComplete() && this.AllNtReached() && this.NoCircularProductions() && this.AllNtToTerm();
                        if (ok) {
                            this.CheckResolvers();
                            this.CheckLL1();
                        }

                        return ok;
                    };

                    //--------------- check for circular productions ----------------------
                    Tab.prototype.GetSingles = function (p, singles) {
                        if (p == null) {
                            return;
                        }
                        if (p.typ == Node.nt) {
                            if (p.up || Tab.DelGraph(p.next)) {
                                singles.push(p.sym);
                            }
                        } else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt) {
                            if (p.up || Tab.DelGraph(p.next)) {
                                this.GetSingles(p.sub, singles);
                                if (p.typ == Node.alt) {
                                    this.GetSingles(p.down, singles);
                                }
                            }
                        }
                        if (!p.up && Tab.DelNode(p)) {
                            this.GetSingles(p.next, singles);
                        }
                    };

                    Tab.prototype.NoCircularProductions = function () {
                        var ok;
                        var changed;
                        var onLeftSide;
                        var onRightSide;
                        var list = [];
                        this.nonterminals.forEach(function (sym) {
                            var singles = [];
                            this.GetSingles(sym.graph, singles);

                            singles.forEach(function (s) {
                                list.push(new CNode(sym, s));
                            });
                        });

                        do {
                            changed = false;
                            for (var i = 0; i < list.length; i++) {
                                var n = list[i];
                                onLeftSide = false;
                                onRightSide = false;

                                list.forEach(function (m) {
                                    if (n.left == m.right)
                                        onRightSide = true;
                                    if (n.right == m.left)
                                        onLeftSide = true;
                                });

                                if (!onLeftSide || !onRightSide) {
                                    list.splice(i, 1);
                                    i--;
                                    changed = true;
                                }
                            }
                        } while(changed);
                        ok = true;
                        list.forEach(function (n) {
                            ok = false;
                            this.errors.SemErr("  " + n.left.name + " --> " + n.right.name);
                        });

                        return ok;
                    };

                    //--------------- check for LL(1) errors ----------------------
                    Tab.prototype.LL1Error = function (cond, sym) {
                        var s = "  LL1 warning in " + this.curSy.name + ": ";
                        if (sym != null) {
                            s += sym.name + " is ";
                        }

                        switch (cond) {
                            case 1:
                                s += "start of several alternatives";
                                break;
                            case 2:
                                s += "start & successor of deletable structure";
                                break;
                            case 3:
                                s += "an ANY node that matches no symbol";
                                break;
                            case 4:
                                s += "contents of [...] or {...} must not be deletable";
                                break;
                        }
                        this.errors.Warning(s);
                    };

                    Tab.prototype.CheckOverlap = function (s1, s2, cond) {
                        var outer = this;
                        this.terminals.forEach(function (sym) {
                            if (s1[sym.n] && s2[sym.n]) {
                                outer.LL1Error(cond, sym);
                            }
                        });
                    };

                    Tab.prototype.CheckAlts = function (p) {
                        var s1;
                        var s2;
                        while (p != null) {
                            if (p.typ == Node.alt) {
                                var q = p;
                                s1 = new coco.BitArray(this.terminals.length, false);
                                while (q != null) {
                                    s2 = this.Expected0(q.sub, this.curSy);
                                    this.CheckOverlap(s1, s2, 1);
                                    s1.Or(s2);
                                    this.CheckAlts(q.sub);
                                    q = q.down;
                                }
                            } else if (p.typ == Node.opt || p.typ == Node.iter) {
                                if (Tab.DelSubGraph(p.sub)) {
                                    this.LL1Error(4, null);
                                } else {
                                    s1 = this.Expected0(p.sub, this.curSy);
                                    s2 = this.Expected(p.next, this.curSy);
                                    this.CheckOverlap(s1, s2, 2);
                                }

                                this.CheckAlts(p.sub);
                            } else if (p.typ == Node.any) {
                                if (Sets.Elements(p.set) == 0) {
                                    this.LL1Error(3, null);
                                }
                            }
                            if (p.up) {
                                break;
                            }
                            p = p.next;
                        }
                    };

                    Tab.prototype.CheckLL1 = function () {
                        var outer = this;
                        this.nonterminals.forEach(function (sym) {
                            outer.curSy = sym;
                            outer.CheckAlts(outer.curSy.graph);
                        });
                    };

                    //------------- check if resolvers are legal  --------------------
                    Tab.prototype.ResErr = function (p, msg) {
                        this.errors.WarningPositioned(p.line, p.pos.col, msg);
                    };

                    Tab.prototype.CheckRes = function (p, rslvAllowed) {
                        while (p != null) {
                            switch (p.typ) {
                                case Node.alt:
                                    var expected = new coco.BitArray(this.terminals.length, false);
                                    for (var q = p; q != null; q = q.down) {
                                        expected.Or(this.Expected0(q.sub, this.curSy));
                                    }

                                    var soFar = new coco.BitArray(this.terminals.length, false);
                                    for (var q = p; q != null; q = q.down) {
                                        if (q.sub.typ == Node.rslv) {
                                            var fs = this.Expected(q.sub.next, this.curSy);
                                            if (Sets.Intersect(fs, soFar)) {
                                                this.ResErr(q.sub, "Warning: Resolver will never be evaluated. " + "Place it at previous conflicting alternative.");
                                            }

                                            if (!Sets.Intersect(fs, expected)) {
                                                this.ResErr(q.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
                                            }
                                        } else {
                                            soFar.Or(this.Expected(q.sub, this.curSy));
                                        }

                                        this.CheckRes(q.sub, true);
                                    }
                                    break;
                                case Node.iter:
                                case Node.opt:
                                    if (p.sub.typ == Node.rslv) {
                                        var fs = this.First(p.sub.next);
                                        var fsNext = this.Expected(p.next, this.curSy);
                                        if (!Sets.Intersect(fs, fsNext)) {
                                            this.ResErr(p.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
                                        }
                                    }

                                    this.CheckRes(p.sub, true);
                                    break;
                                case Node.rslv:
                                    if (!rslvAllowed) {
                                        this.ResErr(p, "Warning: Misplaced resolver: no alternative.");
                                    }
                                    break;
                            }

                            if (p.up) {
                                break;
                            }

                            p = p.next;
                            rslvAllowed = false;
                        }
                    };

                    Tab.prototype.CheckResolvers = function () {
                        var outer = this;
                        this.nonterminals.forEach(function (sym) {
                            outer.curSy = sym;
                            outer.CheckRes(this.curSy.graph, false);
                        });
                    };

                    //------------- check if every nts has a production --------------------
                    Tab.prototype.NtsComplete = function () {
                        var complete = true;
                        var outer = this;
                        this.nonterminals.forEach(function (sym) {
                            if (sym.graph == null) {
                                complete = false;
                                outer.errors.SemErr("  No production for " + sym.name);
                            }
                        });

                        return complete;
                    };

                    //-------------- check if every nts can be reached  -----------------
                    Tab.prototype.MarkReachedNts = function (p) {
                        while (p != null) {
                            if (p.typ == Node.nt && !this.visited[p.sym.n]) {
                                this.visited[p.sym.n] = true;
                                this.MarkReachedNts(p.sym.graph);
                            } else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt) {
                                this.MarkReachedNts(p.sub);
                                if (p.typ == Node.alt) {
                                    this.MarkReachedNts(p.down);
                                }
                            }

                            if (p.up) {
                                break;
                            }
                            p = p.next;
                        }
                    };

                    Tab.prototype.AllNtReached = function () {
                        var ok = true;
                        this.visited = new coco.BitArray(this.nonterminals.length, false);
                        this.visited[this.gramSy.n] = true;
                        this.MarkReachedNts(this.gramSy.graph);
                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            if (!this.visited[sym.n]) {
                                ok = false;
                                this.errors.Warning("  " + sym.name + " cannot be reached");
                            }
                        }
                        return ok;
                    };

                    //--------- check if every nts can be derived to terminals  ------------
                    Tab.prototype.IsTerm = function (p, mark) {
                        while (p != null) {
                            if (p.typ == Node.nt && !mark[p.sym.n]) {
                                return false;
                            }

                            if (p.typ == Node.alt && !this.IsTerm(p.sub, mark) && (p.down == null || !this.IsTerm(p.down, mark))) {
                                return false;
                            }

                            if (p.up) {
                                break;
                            }

                            p = p.next;
                        }
                        return true;
                    };

                    Tab.prototype.AllNtToTerm = function () {
                        var changed;
                        var ok = true;
                        var mark = new coco.BitArray(this.nonterminals.length, false);

                        do {
                            changed = false;
                            for (var i = 0; i < this.nonterminals.length; i++) {
                                var sym = this.nonterminals[i];
                                if (!mark[sym.n] && this.IsTerm(sym.graph, mark)) {
                                    mark[sym.n] = true;
                                    changed = true;
                                }
                            }
                        } while(changed);

                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            if (!mark[sym.n]) {
                                ok = false;
                                this.errors.SemErr("  " + sym.name + " cannot be derived to terminals");
                            }
                        }

                        return ok;
                    };

                    //---------------------------------------------------------------------
                    //  Cross reference list
                    //---------------------------------------------------------------------
                    Tab.prototype.XRef = function () {
                        var xref = {};

                        for (var i = 0; i < this.nonterminals.length; i++) {
                            var sym = this.nonterminals[i];
                            var list = xref[sym.name];
                            if (list == null) {
                                list = [];
                                xref[sym.name] = list;
                            }
                            list.Add(-sym.line);
                        }

                        for (var i = 0; i < this.nodes.length; i++) {
                            var n = this.nodes[i];
                            if (n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt) {
                                var list = xref[n.sym.name];
                                if (list == null) {
                                    list = [];
                                    xref[n.sym.name] = list;
                                }

                                list.Add(n.line);
                            }
                        }

                        // print cross reference list
                        this.trace.WriteLine();
                        this.trace.WriteLineText("Cross reference list:");
                        this.trace.WriteLineText("--------------------");
                        for (var sym in xref) {
                            this.trace.WriteFormatted1("  {0,-12}", this.Name(sym.name));
                            var list = xref[sym.name];
                            var col = 14;
                            for (var j = 0; j < list.length; j++) {
                                var line = list[j];
                                if (col + 5 > 80) {
                                    this.trace.WriteLine();
                                    for (col = 1; col <= 14; col++) {
                                        this.trace.Write(" ");
                                    }
                                }
                                this.trace.WriteFormatted1("{0,5}", line);
                                col += 5;
                            }
                            this.trace.WriteLine();
                        }
                        this.trace.WriteLine();
                        this.trace.WriteLine();
                    };

                    Tab.prototype.SetDDT = function (s) {
                        s = s.toUpperCase();
                        for (var i = 0; i < s.length; i++) {
                            var ch = s.charCodeAt(i);
                            if ('0'.charCodeAt(0) <= ch && ch <= '9'.charCodeAt(0)) {
                                this.ddt[ch - '0'.charCodeAt(0)] = true;
                            } else {
                                switch (ch) {
                                    case 'A':
                                        this.ddt[0] = true;
                                        break;
                                    case 'F':
                                        this.ddt[1] = true;
                                        break;
                                    case 'G':
                                        this.ddt[2] = true;
                                        break;
                                    case 'I':
                                        this.ddt[3] = true;
                                        break;
                                    case 'J':
                                        this.ddt[4] = true;
                                        break;
                                    case 'P':
                                        this.ddt[8] = true;
                                        break;
                                    case 'S':
                                        this.ddt[6] = true;
                                        break;
                                    case 'X':
                                        this.ddt[7] = true;
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    };

                    Tab.prototype.SetOption = function (s) {
                        var option = s.split("=", 2);
                        var name = option[0];
                        var value = option[1];
                        if ("$namespace" == name) {
                            if (this.nsName == null) {
                                this.nsName = value;
                            }
                        } else if ("$checkEOF" == name) {
                            this.checkEOF = "true" == value;
                        }
                    };
                    return Tab;
                })();
                coco.Tab = Tab;
            })(ssw.coco || (ssw.coco = {}));
            var coco = ssw.coco;
        })(jku.ssw || (jku.ssw = {}));
        var ssw = jku.ssw;
    })(at.jku || (at.jku = {}));
    var jku = at.jku;
})(at || (at = {}));
//@ sourceMappingURL=Tab.js.map
